#!/usr/bin/env bash

# Utility name (String)
APP="RPMBuilder"

# Utility version (String)
VER="1.11.0"

####################################################################

NORM=0
BOLD=1
UNLN=4
RED=31
GREEN=32
YELLOW=33
BLUE=34
MAG=35
CYAN=36
GREY=37
DARK=90

CL_NORM="\e[0m"
CL_BOLD="\e[0;${BOLD};49m"
CL_UNLN="\e[0;${UNLN};49m"
CL_RED="\e[0;${RED};49m"
CL_GREEN="\e[0;${GREEN};49m"
CL_YELLOW="\e[0;${YELLOW};49m"
CL_BLUE="\e[0;${BLUE};49m"
CL_MAG="\e[0;${MAG};49m"
CL_CYAN="\e[0;${CYAN};49m"
CL_GREY="\e[0;${GREY};49m"
CL_DARK="\e[0;${DARK};49m"
CL_BL_RED="\e[1;${RED};49m"
CL_BL_GREEN="\e[1;${GREEN};49m"
CL_BL_YELLOW="\e[1;${YELLOW};49m"
CL_BL_BLUE="\e[1;${BLUE};49m"
CL_BL_MAG="\e[1;${MAG};49m"
CL_BL_CYAN="\e[1;${CYAN};49m"
CL_BL_GREY="\e[1;${GREY};49m"

MACRO_NAME="Name"
MACRO_VERSION="Version"
MACRO_RELEASE="Release"
MACRO_EPOCH="Epoch"
MACRO_SUMM="Summary"
MACRO_LICENSE="License"
MACRO_VENDOR="Vendor"
MACRO_GROUP="Group"
MACRO_URL="URL"
MACRO_SOURCE="Source"
MACRO_PATCH="Patch"
MACRO_BUILD_ARCH="BuildArch"
MACRO_BUILD_ROOT="BuildRoot"
MACRO_BUILD_REQS="BuildRequires"
MACRO_REQS="Requires"
MACRO_REQS_PRE="Requires(pre)"
MACRO_REQS_PREUN="Requires(preun)"
MACRO_REQS_POST="Requires(post)"
MACRO_REQS_POSTUN="Requires(postun)"
MACRO_PROVS="Provides"

ERROR_UNKNOWN=1
ERROR_ARGS=2
ERROR_SPEC=3
ERROR_SOURCE=4
ERROR_BUILD=5
ERROR_LINT=6
ERROR_REMOTE=7
ERROR_DEPS=8
ERROR_VALIDATE=9

# Prefix for in spec arguments
INSPEC_ARG_PREFIX="rpmbuilder:"

# List of supported macroses (String)
MACRO="name:Name version:Version release:Release url:URL vendor:Vendor epoch:Epoch"

# User Agent used for all HTTP requests (String)
USER_AGENT="$APP/$VER"

SEPARATOR="----------------------------------------------------------------------------------------"

###############################################################################

# Path to preferencies file
PREFS_FILE="$HOME/.rpmbuilder"

SUPPORTED_ARGS="remote !parallel host user pass key source_dir source_list 
 !sign !no_build !no_clean !no_deps !no_lint !no_source pack !pedantic !strict 
 pre post dest dest_dir upload git svn hg bzr branch revision tag svn_user 
 svn_pass path !bump bump_comment tmp dlcache !depinstall !dep_install github 
 bitbucket launchpad with without define output !verbose !help !usage !ver 
 !version !raw_version qa_rpaths tmux_worker !no_colors !keep_log !notify 
 arch download !relative_pack enable_repo disable_repo exclude_package gopack"

SHORT_ARGS="r:remote P:!parallel hh:host uu:user pp:pass kk:key sd:source_dir 
 sl:source_list NB:!no_build NC:!no_clean ND:!no_deps NR:!no_binary NS:!no_source 
 p:pack 0:!no_lint 1:!strict 2:!pedantic pr:pre ps:post d:dest u:upload 
 su:svn_user sp:svn_pass rp:path b:!bump bc:bump_comment dc:dlcache 
 di:!depinstall rb:branch rt:tag rr:revision gh:github bb:bitbucket lp:launchpad 
 w:with W:without s:!sign D:define O:output V:!verbose h:help v:!version 
 nc:!no_colors kl:!keep_log n:!notify a:arch dl:download R:relative_pack 
 ER:enable_repo DR:disable_repo EX:exclude_package G:gopack"

INSPEC_ARGS="git svn hg bzr branch revision tag svn_user svn_pass github 
 bitbucket launchpad qa_rpaths pedantic strict no_lint relative_pack gopack"

MERGEABLE_ARGS="pack with without enable_repo disable_repo exclude_package define"

KEEP_ARGS=true

###############################################################################

# List of supported archive types (String)
SUPPORTED_ARCH_TYPES="tbz2 tar.bz2 tgz tar.gz tbz tar.bz txz tar.xz"

# Wait delay after successful build in seconds (Number)
TMUX_OK_SLEEP=5

# Wait delay after errored build in seconds (Number)
TMUX_ERROR_SLEEP=1800

# Wait delay after spec linting in seconds (Number)
LINT_WAIT=3

# Maximum duration for "normal" download in seconds (Number)
LONG_DOWNLOADING=60

# Maximum duration for "normal" build in seconds (Number)
LONG_BUILD=300

# Name of build lock file (String)
BUILD_LOCK=".buildlock"

# Default builder home directory (String)
BUILDER_HOME="/home/builder"

# Path to local build lock file (String)
BUILD_LOCK_LOCAL="/tmp/rpmbuilder-local-lock"

# Path to parallel local build lock file (String)
BUILD_LOCK_PARALLEL="/tmp/rpmbuilder-parallel-lock"

# Max lock file lifetime in seconds (Number)
LOCK_TIME_MAX_DIFF=10800 # 3 Hours

# Base SSH options (String)
SSH_BASE_OPTS="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o LogLevel=quiet"

# Local build queue check delay in seconds (Number)
CHECK_LOCAL_QUEUE_DELAY=2

# Remote build queue check delay in seconds (Number)
CHECK_REMOTE_QUEUE_DELAY=15

# Max log quote size in lunes (Number)
LOG_QUOTE_SIZE=50

# Max repository (git/svn/hg/bzr) log quote size in lunes (Number)
REPO_LOG_QUOTE_SIZE=25

# List of possible used directory names for sources (String)
SOURCE_PATHS=". SOURCES SOURCE sources source src"

# Current working dir (String)
CWD=$(pwd)

# Template used for temporary directory name generation (String)
TMP_DIR_TEMPLATE="rpmbuilder-XXXXXXXX"

# Template used for temporary output file name generation (String)
TMP_OUT_TEMPLATE="rpmbuilder-XXXXXXXX.out"

###############################################################################

# Path to directory with temporary data (String)
tmp="/tmp"

# Path to temporary directory for current build (String)
tmp_dir=""

# Path to temporary output file for current build (String)
tmp_output=""

# Current user name (String)
user=$(whoami)

# Packager name (String)
packager=""

verb_output=/dev/null

build_start=0
build_end=0

###############################################################################

# Main function
#
# Code: No
# Echo: No
main() {
  if [[ ! -t 1 || -n "$no_colors" ]] ; then
    unset NORM BOLD UNLN RED GREEN YELLOW BLUE MAG CYAN GREY DARK
    unset CL_NORM CL_BOLD CL_UNLN CL_RED CL_GREEN CL_YELLOW CL_BLUE CL_MAG CL_DARK
    unset CL_CYAN CL_GREY CL_DARK CL_BL_RED CL_BL_GREEN CL_BL_YELLOW CL_BL_BLUE
    unset CL_BL_MAG CL_BL_CYAN CL_BL_GREY
  fi

  [[ -n "$raw_version" ]] && echo $VER && doExit
  [[ -n "$ver" || -n "$version" ]] && about && doExit
  [[ $# -eq 0 || -n "$help" || -n "$usage" ]] && usage && doExit

  local spec="$1"

  if ! isSpecFile "$spec" ; then
    if isSpecFile "${spec}.spec" ; then
      [[ -r "${spec}.source" && -z "$source_list" ]] && source_list="$spec.source"
      spec="${spec}.spec"
    else
      error "${CL_BL_RED}${spec}${CL_RED} is not a spec file!${CL_NORM}"
      doExit $ERROR_SPEC
    fi
  fi

  checkArgs

  trap termExit SIGINT SIGQUIT SIGTERM

  if [[ -n "$parallel" && $(wc -l "$remote" | cut -f1 -d" ") -gt 1 ]] ; then
    parallelBuild "$@"
  else
    sequentialBuild "$@"
  fi

  doExit
}

# Ring the bell
#
# Code: No
# Echo: No
notify() {
  [[ -n "$notify" ]] && bell && return

  local start_ts end_ts time_diff

  start_ts=$1
  end_ts=$(now)
  time_diff=$(( end_ts - start_ts ))

  [[ $time_diff -ge $LONG_BUILD ]] && bell
}

# Start sequential build
#
# *: All options passed to utility 
#
# Code: No
# Echo: No
sequentialBuild() {
  local start_ts
  start_ts=$(now)

  [[ -n "$tmux_worker" ]] && createWorkerLock

  [[ -n "$dest" ]]     && dest_dir="$dest"
  [[ -n "$dest_dir" ]] && dest_dir=$(getAbsPath "$dest_dir")
  [[ -n "$dlcache" ]]  && dlcache=$(getAbsPath "$dlcache")
  [[ -n "$download" ]] && dlcache=$(getAbsPath "$download")

  [[ -n "$key" && -r "$HOME/.ssh/$key" ]] && key="$HOME/.ssh/$key"

  makeTemp

  if [[ -n "$verbose" ]] ; then
    verbose=true
    verb_output=/dev/stdout
  fi

  readInspecArgs "$spec"

  [[ -n "${github}${bitbucket}${launchpad}" ]] && parseSourceURL "$spec"

  [[ -n "$github" ]]    && processGithubSource
  [[ -n "$bitbucket" ]] && processBitbucketSource
  [[ -n "$launchpad" ]] && processLaunchpadSource

  if [[ -n "$download" ]] ; then
    downloadRemoteSources "$spec"
  else
    if [[ -n "$remote" ]] ; then
      remoteBuild "$spec"
    else
      localBuild "$spec"
    fi
  fi

  [[ -n "$tmux_worker" ]] && removeWorkerLock

  notify "$start_ts"
}

# Start parallel build in tmux
#
# *: All options passed to utility 
#
# Code: No
# Echo: No
parallelBuild() {
  if [[ ! -r $remote ]] ; then
    error "Error! Can't start parallel build process - builder list not readable." $RED
    doExit $ERROR_ARGS
  fi

  if [[ -n "$dlcache" ]] ; then
    error "Warning! You can't use a parallel build with download cache." $YELLOW
    doExit $ERROR_ARGS
  fi

  local args=""
  local arg

  for arg in "$@" ; do
    [[ "$arg" == "-r" ]] && continue
    [[ "$arg" == "--remote" ]] && continue
    [[ "$arg" == "-P" ]] && continue
    [[ "$arg" == "--parallel" ]] && continue
    [[ "$arg" == "$remote" ]] && continue

    args="$args $arg"
  done

  checkParalellBuildAvailability
  createParalellLock

  local serv serv_name session_exist wid
  local wids=()

  while read serv ; do
    serv_name=$(echo "$serv" | cut -f2 -d"@")
    wid=$(mktemp -u XXXXXXXXXXXX)

    wids+=($wid)

    if [[ -z "$session_exist" ]] ; then
      if [[ -z "$TMUX" ]] ; then
        tmux new-session -s "rpmbuilder" -d "$0 $args -r $serv --tmux-worker $wid" >/dev/null 2>&1
      else
        tmux new-window "$0 $args -r $serv --tmux-worker $wid"
      fi

      tmux rename-window "$APP"
      session_exist=true
    else
      tmux split-window "$0 $args -r $serv --tmux-worker $wid" >/dev/null 2>&1
    fi
  done < "$remote"

  # If we not in tmux, attach to session
  if [[ -z "$TMUX" ]] ; then
    tmux attach-session -t "rpmbuilder" >/dev/null 2>&1
  fi

  waitTillWorkersComplete "${wids[*]}"
  removeParalellLock

  show "Parallel build complete" $GREEN
}

checkParalellBuildAvailability() {
  if ! hasParalellLock ; then
    return
  fi

  local cdt ct cdf

  cdt=$(stat $BUILD_LOCK_PARALLEL -c "%Y" 2> /dev/null)
  ct=$(now)
  cdf=$(( ct - cdt ))

  if [[ $cdf -gt $LOCK_TIME_MAX_DIFF ]] ; then
    error "We found lock file created more than 3 hours ago. It's too much time for the usual build process." $YELLOW
    error "If another build process doesn't occur, you must remove file $BUILD_LOCK_PARALLEL manually." $YELLOW
    error "We will continue to build when this file will be removed." $YELLOW
  else
    error "Another parallel build process in progress." $YELLOW
    error "We will continue to build when another process complete." $YELLOW
  fi

  while : ; do
    sleep $CHECK_LOCAL_QUEUE_DELAY

    if ! hasParalellLock ; then
      break
    fi
  done
}

hasParalellLock() {
  [[ ! -e $BUILD_LOCK_PARALLEL ]] && return 1

  local pid
  pid=$(cat "$BUILD_LOCK_PARALLEL")

  if [[ ! -d "/proc/$pid" ]] ; then
    if removeParalellLock ; then
      return 1
    fi
  fi

  return 0
}

createParalellLock() {
  echo "$$" 1> "$BUILD_LOCK_PARALLEL" 2> /dev/null
  chmod 666 "$BUILD_LOCK_PARALLEL" &> /dev/null
}

removeParalellLock() {
  local cur_user lock_owner

  if [[ -f $BUILD_LOCK_PARALLEL ]] ; then
    cur_user=$(whoami)
    lock_owner=$(stat "$BUILD_LOCK_PARALLEL" -c "%U")

    if [[ "$cur_user" == "$lock_owner" ]] ; then
      rm -f "$BUILD_LOCK_PARALLEL" &> /dev/null
    fi
  fi
}

createWorkerLock() {
  local wid="$tmux_worker"
  local lock_file

  if ! hasWorkerLock "$wid" ; then
    lock_file=$(getPathToWorkerLock "$wid")
    echo "$$" 1> "$lock_file" 2> /dev/null
    chmod 666 "$lock_file" &> /dev/null
  fi
}

removeWorkerLock() {
  local wid="$tmux_worker"
  local lock_file

  if hasWorkerLock "$wid" ; then
    lock_file=$(getPathToWorkerLock "$wid")
    rm -f "$lock_file" &> /dev/null
  fi
}

hasWorkerLock() {
  local wid="$1"
  local lock_file pid

  lock_file=$(getPathToWorkerLock "$wid")

  if [[ ! -e "$lock_file" ]] ; then
    return 1
  fi

  pid=$(cat "$lock_file")

  if [[ ! -e "/proc/$pid" ]] ; then
    rm -f "$lock_file" &> /dev/null
    return 1
  fi

  return 0
}

getPathToWorkerLock() {
  echo "${tmp:?}/.rpmbuilder-worker-$wid"
}

waitTillWorkersComplete() {
  local wid has_lock lock_file

  show "Waiting till remote builds complete..." $DARK

  while : ; do
    sleep 1

    has_lock=""

    for wid in $@ ; do
      if hasWorkerLock "$wid" ; then
        has_lock=true
      fi
    done

    if [[ -z "$has_lock" ]] ; then
      break
    fi
  done

  sleep $TMUX_OK_SLEEP
}

checkArgs() {
  if [[ -n "$key" ]] ; then
    if [[ ! -r "$key" && ! -r "$HOME/.ssh/$key" ]] ; then
      error "Can't start build process - key file is not readable." $RED
      doExit $ERROR_ARGS
    fi
  fi

  if [[ -n "$parallel" && -z "$remote" ]] ; then
    error "Can't start build process - remote build server not defined." $RED
    doExit $ERROR_ARGS
  fi

  if [[ -n "$dest_dir" && ! -d $dest_dir ]] ; then
    error "Can't start build process - destination directory doesn't exist." $RED
    doExit $ERROR_ARGS
  fi

  if [[ -n "$dlcache" && ! -d $dlcache ]] ; then
    error "Can't start build process - download cached directory doesn't exist." $RED
    doExit $ERROR_ARGS
  fi

  if [[ -n "$remote" && -z "$host" && ! -r $remote && ! "$remote" =~ \@|\~ && ! "$remote" =~ :[0-9]{1,}$ ]] ; then
    error "Can't start remote build process - you must define the remote host." $RED
    doExit $ERROR_ARGS
  fi

  if ! checkDeps "git" && [[ -n "$git" ]] ; then
    error "Can't start build process - for using --git argument, you must install git first." $RED
    doExit $ERROR_DEPS
  fi

  if ! checkDeps "svn" && [[ -n "$svn" ]] ; then
    error "Can't start build process - for using --svn argument, you must install svn first." $RED
    doExit $ERROR_DEPS
  fi

  if ! checkDeps "hg" && [[ -n "$hg" ]] ; then
    error "Can't start build process - for using --hg argument, you must install hg first." $RED
    doExit $ERROR_DEPS
  fi

  if ! checkDeps "bzr" && [[ -n "$bzr" ]] ; then
    error "Can't start build process - for using --bzr argument, you must install bzr first." $RED
    doExit $ERROR_DEPS
  fi

  if ! checkDeps "gopack" && [[ -n "$gopack" ]] ; then
    error "Can't start build process - for using --gopack argument, you must install gopack first." $RED
    doExit $ERROR_DEPS
  fi

  if ! checkDeps "sshpass" && [[ -n "$pass" ]] ; then
    error "Can't start build process - for using --pass argument, you must install sshpass first." $RED
    doExit $ERROR_DEPS
  fi

  if ! checkDeps "rpmbuild" "rpmlint" && [[ -z "$remote" ]] ; then
    error "Can't start local build process -  you must install rpmbuild and rpmlint first." $RED
    doExit $ERROR_DEPS
  fi

  if ! checkDeps "rpm" && [[ -n "$sign" && -z "$remote" ]] ; then
    error "Can't start local build process - for signing packages you must install rpm first." $RED
    doExit $ERROR_DEPS
  fi

  if [[ ! -d $tmp ]] ; then
    error "Can't start build process - temp directory doesn't exist." $RED
    doExit $ERROR_UNKNOWN
  fi

  if [[ -n "$dlcache" && ! -d $dlcache ]] ; then
    error "Can't start build process - download cache directory doesn't exist." $RED
    doExit $ERROR_UNKNOWN
  fi

  if [[ -n "$bump" ]] ; then
    if ! checkDeps "rpmdev-packager" "rpmdev-bumpspec" ; then
      error "Can't start build process - for automatic release bumping you must install
      rpmdev-bumpspec and rpmdev-packager (from rpmdevtools package) first." $RED
      doExit $ERROR_DEPS
    fi

    packager=$(rpmdev-packager)

    if [[ -z "$packager" ]] ; then
      error "Can't start build process - for automatic release bumping you must define %packager
      (name + email e.g. \"%packager John Smith <mail@smith.com>\") value in file ~/.rpmmacros" $RED
      doExit $ERROR_UNKNOWN
    fi
  fi
}

readInspecArgs() {
  local spec="$1"
  local arg line argn

  while read line ; do
    IFS=" " read -ra arg <<< "$line"

    argn="${arg[0]//-/_}"

    if [[ -z "${!argn}" && $INSPEC_ARGS\  =~ $argn\  ]] ; then
      eval "$argn=${arg[@]:1:99}"
    fi
  done < <(grep "$INSPEC_ARG_PREFIX" "$spec" | sed "s/# \?$INSPEC_ARG_PREFIX//g" | tr -s " ")
}

processGithubSource() {
  local github_user github_repo github_tag github_branch github_act

  local delim

  local is_branch is_tag

  if [[ -n "$branch" ]] ; then
    is_branch=true
  else
    is_tag=true
  fi

  if [[ "$github" =~ (http|https) ]] ; then
    github_user=$(echo "$github" | cut -f4 -d"/")
    github_repo=$(echo "$github" | cut -f5 -d"/")
    github_act=$(echo "$github" | cut -f6 -d"/")

    if [[ "$github_act" =~ (zip|tar)ball ]] ; then
      github_tag=$(echo "$github" | cut -f7 -d"/")

      [[ -n "$is_tag" ]] && tag="$github_tag"
      [[ -n "$is_branch" ]] && branch="$github_tag"
    elif [[ "$github_act" == "tree" ]] ; then
      github_branch=$(echo "$github" | cut -f7 -d"/")
      branch="$github_branch"
    fi
  else
    if [[ "$github" =~ \: ]] ; then
      delim=":"
    elif [[ "$github" =~ \/ ]] ; then
      delim="/"
    else
      return 1
    fi

    github_user=$(echo "$github" | cut -f1 -d"$delim")
    github_repo=$(echo "$github" | cut -f2 -d"$delim")

    [[ -z "$github_user" || -z "$github_repo" ]] && return
  fi

  git="git://github.com/${github_user}/${github_repo}.git"
}

processBitbucketSource() {
  local bitbucket_user bitbucket_repo bitbucket_tag bitbucket_branch bitbucket_act

  local delim

  local is_branch is_tag is_git is_hg

  if [[ -n "$hg" ]] ; then
    is_hg=true
  else
    is_git=true
  fi

  if [[ "$bitbucket" =~ (http|https) ]] ; then
    bitbucket_user=$(echo "$bitbucket" | cut -f4 -d"/")
    bitbucket_repo=$(echo "$bitbucket" | cut -f5 -d"/")
    bitbucket_act=$(echo "$bitbucket" | cut -f6 -d"/")

    if [[ "$bitbucket_act" == "get" ]] ; then
      bitbucket_tag=$(echo "$bitbucket" | cut -f7 -d"/" | sed 's/.zip\|.tar.gz\|.tar.bz2//g')

      if [[ -n "$branch" ]] ; then
        is_branch=true
      else
        is_tag=true
      fi

      [[ -n "$is_tag" ]] && tag="$bitbucket_tag"
      [[ -n "$is_branch" ]] && branch="$bitbucket_tag"
    elif [[ "$bitbucket" =~ \?at= ]] ; then
      bitbucket_branch=$(echo "$bitbucket" | cut -f2 -d"=")

      if [[ -n "$tag" ]] ; then
        is_tag=true
      else
        is_branch=true
      fi

      [[ -n "$is_tag" ]] && tag="$bitbucket_branch"
      [[ -n "$is_branch" ]] && branch="$bitbucket_branch"
    fi
  else
    if [[ "$bitbucket" =~ \: ]] ; then
      delim=":"
    elif [[ "$bitbucket" =~ \/ ]] ; then
      delim="/"
    else
      return 1
    fi

    bitbucket_user=$(echo "$bitbucket" | cut -f1 -d"$delim")
    bitbucket_repo=$(echo "$bitbucket" | cut -f2 -d"$delim")

    [[ -z "$bitbucket_user" || -z "$bitbucket_repo" ]] && return
  fi

  if [[ -n "$is_git" ]] ; then
    git="git@bitbucket.org:${bitbucket_user}/${bitbucket_repo}.git"
  else
    hg="ssh://hg@bitbucket.org/${bitbucket_user}/${bitbucket_repo}"
  fi
}

processLaunchpadSource() {
  local launchpad_repo

  if [[ "$launchpad" =~ (http|https) ]] ; then
    launchpad_repo=$(echo "$launchpad" | cut -d"/" -f4-99)

    if [[ "$launchpad_repo" =~ revision/ ]] ; then
      bzr=$(echo "$launchpad_repo" | cut -f1-3 -d"/")
      revision=$(echo "$launchpad_repo" | cut -f5 -d"/")
    else
      bzr="lp:$launchpad_repo"
    fi
  else
    bzr="$launchpad"
  fi
}

parseSourceURL() {
  local spec="$1"

  local url
  url=$(getSpecValue "$MACRO_URL" "$spec")

  if [[ "$url" =~ github ]] ; then
    github="$url"
  elif [[ "$url" =~ bitbucket ]] ; then
    bitbucket="$url"
  elif [[ "$url" =~ launchpad ]] ; then
    launchpad="$url"
  else
    return 1
  fi
}

makeTemp() {
  tmp_output=$(mktemp "${tmp:?}/$TMP_OUT_TEMPLATE")
  tmp_dir=$(mktemp -d "${tmp:?}/$TMP_DIR_TEMPLATE")

  if [[ ! -f "$tmp_output" || ! -d "$tmp_dir" ]] ; then
    error "Can't start build process - temp file can't be created" $RED
    doExit $ERROR_UNKNOWN
  fi
}

downloadRemoteSources() {
  local spec="$1"
  local download_count=0

  if [[ "$download" == "true" ]] ; then
    dlcache="."
  fi

  showSeparator "DOWNLOADING"

  if [[ ! -d "$dlcache" ]] ; then
    error "Can't download sources - download destination directory doesn't exist" $RED
    doExit $ERROR_ARGS
  fi

  [[ -n "$git" ]]    && packSourcesFromGit "$spec"
  [[ -n "$svn" ]]    && packSourcesFromSvn "$spec"
  [[ -n "$bzr" ]]    && packSourcesFromBzr "$spec"
  [[ -n "$hg" ]]     && packSourcesFromHg  "$spec"
  [[ -n "$gopack" ]] && packGolangSources  "$spec"

  local source_file sources_list source_file_name patches_list files

  sources_list=$(getSpecValue "$MACRO_SOURCE" "$spec")
  patches_list=$(getSpecValue "$MACRO_PATCH" "$spec")

  files="$sources_list $patches_list"

  for source_file in $files ; do
    if [[ "$source_file" =~ ^(http|https|ftp) ]] ; then
      source_file_name=$(basename "$source_file")

      if [[ -f "$dlcache/$source_file_name" ]] ; then
        show "File ${CL_CYAN}${source_file_name}${CL_NORM} already downloaded."
        continue
      fi

      show "Downloading source file ${CL_CYAN}${source_file}${CL_NORM}..."

      downloadSource "$source_file" "$download"

      if [[ $? -ne 0 ]] ; then
        error "Error! Can't download file ${CL_BL_RED}${source_file}${CL_RED}." $RED
        doExit $ERROR_SOURCE
      fi

      ((download_count++))
    fi
  done

  if [[ $download_count -ne 0 ]] ; then
    show "\n${CL_GREEN}All source files downloaded and stored to a ${CL_BL_GREEN}${dlcache}${CL_GREEN} directory${CL_NORM}"
  fi

  showSeparator
}

remoteBuild() {
  local spec="$1"

  showSeparator "PREPARATION"

  if [[ -n "$pre" ]] ; then
    show "Executing pre-build script..."
    $($pre)
  fi

  [[ -n "$git" ]]    && packSourcesFromGit "$spec"
  [[ -n "$svn" ]]    && packSourcesFromSvn "$spec"
  [[ -n "$bzr" ]]    && packSourcesFromBzr "$spec"
  [[ -n "$hg" ]]     && packSourcesFromHg  "$spec"
  [[ -n "$gopack" ]] && packGolangSources  "$spec"

  [[ -n "$repo_spec" ]] && spec="$repo_spec"

  [[ -n "$pack" || -n "$source_list" ]] && packSources "$spec" && show ""

  processSpec "$spec"

  show ""
  show "All source files are ready for build" $GREEN

  if [[ -r $remote ]] ; then
    remoteRunMultibuild "$spec"
  else
    remoteRunBuild "$spec"
  fi
}

remoteRunMultibuild() {
  local spec="$1"

  local build_hosts protect_user protect_pass protect_arch
  local host_info r_user r_pass r_arch

  build_hosts=$(cat "$remote")

  for build_host in $build_hosts ; do
    host_info=($(getURLVars "$build_host"))

    host="${host_info[0]/-/}"

    r_user="${host_info[1]/-/}"
    r_pass="${host_info[2]/-/}"
    r_arch="${host_info[3]/-/}"

    [[ -z "$protect_user" ]] && user="$r_user"
    [[ -z "$protect_pass" ]] && pass="$r_pass"
    [[ -z "$protect_arch" ]] && arch="$r_arch"

    remoteRunBuild "$spec"
  done
}

remoteRunBuild() {
  local spec="$1"

  local host_info r_file r_line r_arch tlines

  if [[ "$remote" =~ :[0-9]{1,}$ ]] ; then
    r_file=$(echo "$remote" | cut -f1 -d":")
    r_line=$(echo "$remote" | cut -f2 -d":")
    tlines=$(wc -l "$r_file" | cut -f1 -d" ")

    if [[ $r_line -gt $tlines ]] ; then
      show ""
      error "Error - file ${CL_BL_RED}${r_file}${CL_RED} don't contain a line with number ${CL_BL_RED}${r_line}${CL_RED}." $RED
      return 1
    fi

    remote=$(sed -n "${r_line}p" "$r_file")
  fi

  if [[ "$remote" =~ \@|\~i ]] ; then
    host_info=($(getURLVars "$remote"))

    host="${host_info[0]/-/}"

    r_user="${host_info[1]/-/}"
    r_pass="${host_info[2]/-/}"
    r_arch="${host_info[3]/-/}"

    user="${r_user:-$user}"
    pass="${r_pass:-$pass}"
    arch="${r_arch:-$arch}"
  fi

  remoteCheckEnv

  showSeparator "SOURCES UPLOADING"

  uploadSourcesToRemoteHost "$spec"

  if [[ -n "$depinstall" || -n "$dep_install" ]] ; then
    showSeparator "DEPENDENCIES INSTALL"
    remoteDepsInstall "$spec"
  fi

  [[ -n "$no_build" ]] && show "" && return

  remoteBuildProcess "$spec"
}

remoteCheckEnv() {
  showSeparator "REMOTE CHECK"

  show "Connecting to a remote build server on ${CL_CYAN}$host${CL_NORM}."

  if isRemoteServerReachable "$host" ; then
    if ! isSSHConnectionWorks "$user" "$host" ; then
      error "Can't connect to host ${CL_BL_RED}${host}${CL_RED}." $RED
      doExit $ERROR_REMOTE
    fi
  else
    error "Remote server ${CL_BL_RED}${host}${CL_RED} is not reachable!" $RED
    doExit $ERROR_REMOTE
  fi

  # Print info about node
  sshCommand "$user@$host" "$BUILDER_HOME/nodeinfo 2>/dev/null"

  # Initialize build environment
  sshCommand "$user@$host" "$BUILDER_HOME/initenv" &> /dev/null
}

remoteDepsInstall() {
  local spec="$1"

  local rpmbuild_dir specs_dir yum_opts

  rpmbuild_dir=$(getRPMBuildDir)
  specs_dir="$rpmbuild_dir/SPECS"

  show "Installing required packages for build...\n"

  yum_opts=$(getYumOpts "$verbose")

  sshCommand "$user@$host" "sudo yum $yum_opts clean expire-cache && cd $specs_dir && sudo yum-builddep $yum_opts -y $spec"

  if [[ $? -ne 0 ]] ; then
    show ""
    error "Can't install required dependencies" $RED
    doExit $ERROR_DEPS
  fi

  show ""
  show "All required packages installed" $GREEN
}

remoteSpecValidate() {
  local spec="$1"

  local rpmbuild_dir specs_dir result

  rpmbuild_dir=$(getRPMBuildDir)
  specs_dir="$rpmbuild_dir/SPECS"

  result=$(sshCommand "$user@$host" "cd $specs_dir && rpmlint $spec" 2> /dev/null)

  show "Spec file check result:" $CYAN
  show "$result"

  if [[ -n "$strict" && $(echo "$result" | grep " E: ") ]] ; then
    show ""
    error "Build canceled because spec has errors and strict mode is enabled" $YELLOW
    doExit $ERROR_LINT
  fi

  if [[ -n "$pedantic" ]] ; then
    if [[ $(echo "$result" | grep " E: ") || $(echo "$result" | grep " W: ") ]] ; then
      show ""
      error "Build canceled because spec has errors or warnings and a pedantic mode is enabled" $YELLOW
      doExit $ERROR_LINT
    fi
  fi

  [[ -n "$verbose" ]] && sleep $LINT_WAIT
}

remoteBuildProcess() {
  local spec="$1"

  local spec_name build_args build_prfx rpmbuild_dir specs_dir

  spec_name=$(basename "$spec")
  build_args=$(getBuildArgs)
  build_prfx=$(getBuildPrfx)
  rpmbuild_dir=$(getRPMBuildDir)
  specs_dir="$rpmbuild_dir/SPECS"

  if [[ -z "$no_lint" ]] ; then
    showSeparator "VALIDATION"
    remoteSpecValidate "$spec_name"
  fi

  showSeparator "BUILD"

  checkRemoteAvailability

  build_start=$(now)

  startStatusObserver

  if [[ -n "$verbose" ]] ; then
    sshCommand "$user@$host" "cd $specs_dir && $build_prfx rpmbuild $spec_name $build_args" | tee "$tmp_output" &> $verb_output
  else
    sshCommand "$user@$host" "cd $specs_dir && $build_prfx rpmbuild $spec_name $build_args" 1> "$tmp_output" 2> /dev/null
  fi

  stopStatusObserver

  show ""

  local has_errors bld_time grc_time packages package_name package_file

  has_errors=$(tail -1 "$tmp_output" | grep -v "exit 0")

  if [[ -z "$has_errors" ]] ; then
    build_end=$(now)
    bld_time=$(( build_end - build_start ))
    grc_time=$(getGraceTime "$bld_time")

    show "Build complete! The build took $grc_time." $GREEN

    showSeparator "PACKAGE PROCESSING"

    packages=$(egrep "rpmbuild/(S|)RPMS" "$tmp_output" | cut -f2 -d" ")

    for package in $packages ; do
      package=$(echo "$package" | tr -dc '[:print:]')
      package_name=$(basename "$package")

       if [[ -n "$sign" ]] ; then
        show "Signing package ${CL_CYAN}$package_name${CL_NORM}..."
        remoteSign "$package"
      fi

      if [[ -n "$dest_dir" ]] ; then
        downloadFromRemoteHost "$package" "$dest_dir"
      else
        downloadFromRemoteHost "$package"
      fi

      if [[ $? -eq 0 ]] ; then
        show "Result: ${CL_CYAN}$package_name${CL_NORM}"
      else
        show "Result: ${CL_CYAN}$package_name${CL_NORM} ${CL_DARK}(ALREADY EXIST)${CL_NORM}"
      fi
    done

    showSeparator "PACKAGE VALIDATION"

    has_errors=""

    for package in $packages ; do
      package=$(echo "$package" | tr -dc '[:print:]')
      package_name=$(basename "$package")
      package_file="$CWD/$package_name"

      [[ -n "$dest_dir" ]] && package_file="$dest_dir/$package_name"

      if ! validatePackage "$package_file" ; then
        has_errors=true
      fi
    done

    if [[ -n "$has_errors" ]] ; then
      doExit $ERROR_VALIDATE
    fi

    if [[ -n "$post" ]] ; then
      show "Executing post-build script..."
      $($post)
    fi

    [[ -n "$bump" ]] && releaseBump "$CWD/$spec"

    if [[ -n "$dest_dir" ]] ; then
      if [[ -n "$upload" ]] ; then
        uploadPackages "$dest_dir" "$packages"
      else
        show ""
        show "All rpm packages saved to a directory ${CL_BL_GREEN}${dest_dir}" $GREEN
      fi
    else
      if [[ -n "$upload" ]] ; then
        uploadPackages "$CWD" "$packages"
      else
        show ""
        show "All rpm packages saved to a current directory" $GREEN
      fi
    fi
  else
    error "Error! Can't build a package." $RED

    if [[ -z "$verbose" ]] ; then
      error "Last $LOG_QUOTE_SIZE lines from build log:" $RED

      showSeparator
      tail -${LOG_QUOTE_SIZE} "$tmp_output" 1>&2
      showSeparator
    fi

    if [[ -n "$keep_log" ]] ; then
      local ldate lname

      ldate=$(getLogDate)
      lname="${spec_name/.spec/}+$host+$ldate.log"

      cp "$tmp_output" "$CWD/$lname"

      show "Build log saved to a current directory as ${CL_BL_YELLOW}${lname}" $YELLOW
    fi

    doExit $ERROR_BUILD
  fi
}

checkRemoteAvailability() {
  local remote_available

  remote_available=$(sshCommand "$user@$host" "stat $BUILD_LOCK &> /dev/null || echo 1")

  if [[ -z "$remote_available" ]] ; then
    showt "\r${CL_GREEN}Executing:${CL_NORM} ${CL_YELLOW}waiting in queue${CL_NORM}"

    while : ; do
      sleep $CHECK_REMOTE_QUEUE_DELAY

      showt "\r${CL_GREEN}Executing:${CL_NORM} ${CL_CYAN}checking queue${CL_NORM}"

      remote_available=$(sshCommand "$user@$host" "stat $BUILD_LOCK &> /dev/null || echo 1")

      if [[ -n "$remote_available" ]] ; then
        showt "\r${CL_GREEN}Executing:${CL_NORM} ${CL_YELLOW}~${CL_NORM}"
        break
      else
        showt "\r${CL_GREEN}Executing:${CL_NORM} ${CL_YELLOW}waiting in queue${CL_NORM}"
      fi
    done
  fi
}

remoteSign() {
  local package="$1"

  sshCommand "$user@$host" "rpm --addsign $package &> /dev/null" 2> /dev/null
}

localBuild() {
  local spec="$1"

  showSeparator "PREPARATION"

  if [[ -n "$pre" ]] ; then
    show "Executing pre-build script..."
    $($pre)
  fi

  [[ -n "$git" ]]    && packSourcesFromGit "$spec"
  [[ -n "$svn" ]]    && packSourcesFromSvn "$spec"
  [[ -n "$bzr" ]]    && packSourcesFromBzr "$spec"
  [[ -n "$hg" ]]     && packSourcesFromHg  "$spec"
  [[ -n "$gopack" ]] && packGolangSources  "$spec"

  [[ -n "$repo_spec" ]] && spec="$repo_spec"

  [[ -n "$pack" || -n "$source_list" ]] && packSources "$spec" && show ""

  processSpec "$spec"

  show ""
  show "All source files are ready for build" $GREEN

  copySourcesToBuildDir "$spec"

  if [[ -n "$depinstall" || -n "$dep_install" ]] ; then
    showSeparator "DEPENDENCIES INSTALL"
    localDepsInstall "$spec"
  fi

  [[ -n "$no_build" ]] && show "" && return

  localBuildProcess "$spec"
}

localDepsInstall() {
  local spec="$1"

  show "Installing required packages for build...\n"

  local yum_opts
  yum_opts=$(getYumOpts "$verbose")

  if [[ "$user" == "root" ]] ; then
    yum $yum_opts clean expire-cache
    yum-builddep $yum_opts -y "$spec"
  else
    sudo yum $yum_opts clean expire-cache
    sudo yum-builddep $yum_opts -y "$spec"
  fi

  if [[ $? -ne 0 ]] ; then
    show ""
    error "Can't install required dependencies" $RED
    doExit $ERROR_DEPS
  fi

  show ""
  show "All required packages installed" $GREEN
}

localSpecValidate() {
  if ! checkDeps "rpmlint" ; then
    error "Can't validate spec file - rpmlint not installed!" $RED
    return 1
  fi

  local spec="$1"

  local result
  result=$(rpmlint "$spec")

  show "Spec file check result:" $CYAN
  show "$result"

  if [[ -n "$strict" && $(echo "$result" | grep " E: ") ]] ; then
    show ""
    error "Build canceled because spec has errors and strict mode is enabled" $YELLOW
    doExit $ERROR_LINT
  fi

  if [[ -n "$pedantic" ]] ; then
    if [[ $(echo "$result" | grep " E: ") || $(echo "$result" | grep " W: ") ]] ; then
      show ""
      error "Build canceled because spec has errors or warnings and a pedantic mode is enabled" $YELLOW
      doExit $ERROR_LINT
    fi
  fi

  [[ -n "$verbose" ]] && sleep $LINT_WAIT
}

localBuildProcess() {
  local spec="$1"

  local spec_name build_args build_prfx rpmbuild_dir specs_dir

  spec_name=$(basename "$spec")
  build_args=$(getBuildArgs)
  build_prfx=$(getBuildPrfx)
  rpmbuild_dir=$(getRPMBuildDir)
  specs_dir="$rpmbuild_dir/SPECS"

  local has_errors

  pushd "$specs_dir" &> /dev/null
    if [[ -z "$no_lint" ]] ; then
      showSeparator "VALIDATION"
      localSpecValidate "$spec_name"
    fi

    showSeparator "BUILD"

    checkLocalBuildAvailability

    build_start=$(now)

    createLocalLock

    startStatusObserver

    # We use eval in this case because using --define, contains quotes
    # and if we simply run command, we will get error

    local exit_status pipe_status

    if [[ -n "$verbose" ]] ; then
      export $build_prfx
      eval "rpmbuild $build_args $spec_name" | tee "$tmp_output" &> $verb_output
      pipe_status=${PIPESTATUS[0]}
    else
      export $build_prfx
      eval "rpmbuild $build_args $spec_name" &> "$tmp_output"
      exit_status=$?
    fi

    if [[ -n "$verbose" ]] ; then
      [[ $pipe_status -ne 0 ]] && has_errors=true
    else
      [[ $exit_status -ne 0 ]] && has_errors=true
    fi

    unset exit_status pipe_status

    if [[ -n "$has_errors" ]] ; then
      stopStatusObserver
      show ""

      error "Error! Can't build a package." $RED

      if [[ -z "$verbose" ]] ; then
        error "Last $LOG_QUOTE_SIZE lines from build log:" $RED

        showSeparator
        tail -${LOG_QUOTE_SIZE} "$tmp_output" 1>&2
        showSeparator
      fi

      if [[ -n "$keep_log" ]] ; then
        local ldate lname

        ldate=$(getLogDate)
        lname="${spec_name/.spec/}+$ldate.log"

        cp "$tmp_output" "$CWD/$lname"

        error "Build log saved to current directory as ${CL_BL_YELLOW}${lname}" $YELLOW
      fi

      removeLocalLock

      doExit $ERROR_BUILD
    else
      stopStatusObserver

      show ""

      local bld_time grc_time package packages package_name package_file

      build_end=$(now)
      bld_time=$(( build_end - build_start ))
      grc_time=$(getGraceTime "$bld_time")

      show "Build complete! The build took $grc_time." $GREEN

      showSeparator "PACKAGE PROCESSING"

      packages=$(egrep "rpmbuild/(S|)RPMS" "$tmp_output" | cut -f2 -d" ")

      rm -f "$tmp_output"

      for package in $packages ; do
        package_name=$(basename "$package")

        if [[ -n "$sign" ]] ; then
          localSign "$package"
        else
          show "Result: ${CL_CYAN}$package_name${CL_NORM}"
        fi

        if [[ -n "$dest_dir" ]] ; then
          mv "$package" "$dest_dir"
        else
          mv "$package" "$CWD"
        fi
      done

      showSeparator "PACKAGE VALIDATION"

      has_errors=""

      for package in $packages ; do
        package_name=$(basename "$package")
        package_file="$CWD/$package_name"

        [[ -n "$dest_dir" ]] && package_file="$dest_dir/$package_name"

        if ! validatePackage "$package_file" ; then
          has_errors=true
        fi
      done

      if [[ -n "$has_errors" ]] ; then
        removeLocalLock
        doExit $ERROR_VALIDATE
      fi

      pushd "$CWD" &> /dev/null

      if [[ -n "$post" ]] ; then
        show "Executing post-build script..."
        $($post)
      fi

      popd &> /dev/null

      [[ -n "$bump" ]] && releaseBump "$CWD/$spec"

      if [[ -n "$dest_dir" ]] ; then
        if [[ -n "$upload" ]] ; then
          uploadPackages "$dest_dir" "$packages"
        else
          show ""
          show "All rpm packages saved to a directory $dest_dir"
        fi
      else
        if [[ -n "$upload" ]] ; then
          uploadPackages "$CWD" "$packages"
        else
          show ""
          show "All rpm packages saved to a current directory" $GREEN
        fi
      fi
    fi

    removeLocalLock

  popd &> /dev/null
}

checkLocalBuildAvailability() {
  if ! hasLocalLock ; then
    return
  fi

  local cdt ct cdf

  cdt=$(stat "$BUILD_LOCK_LOCAL" -c "%Y" 2> /dev/null)
  ct=$(now)
  cdf=$(( ct - cdt ))

  if [[ $cdf -gt $LOCK_TIME_MAX_DIFF ]] ; then
    error "We found lock file created more than 3 hours ago. It's too much time for the usual build process." $YELLOW
    error "If another build process doesn't occur, you must remove file $BUILD_LOCK_LOCAL manually." $YELLOW
    error "We will continue to build when this file will be removed." $YELLOW
    error ""
  fi

  showt "\r${CL_GREEN}Executing:${CL_NORM} ${CL_YELLOW}waiting in queue${CL_NORM}"

  while : ; do
    sleep $CHECK_LOCAL_QUEUE_DELAY

    if ! hasLocalLock ; then
      showt "\r${CL_GREEN}Executing:${CL_NORM} ${CL_YELLOW}~${CL_NORM}"
      break
    fi
  done
}

hasLocalLock() {
  [[ ! -e "$BUILD_LOCK_LOCAL" ]] && return 1

  local pid
  pid=$(cat "$BUILD_LOCK_LOCAL")

  if [[ ! -d "/proc/$pid" ]] ; then
    if removeLocalLock ; then
      return 1
    fi
  fi

  return 0
}

createLocalLock() {
  if ! hasLocalLock ; then
    echo "$$" 1> $BUILD_LOCK_LOCAL 2> /dev/null
    chmod 666 "$BUILD_LOCK_LOCAL" &> /dev/null
  fi
}

removeLocalLock() {
  local cur_user lock_owner

  if [[ -f $BUILD_LOCK_LOCAL ]] ; then
    cur_user=$(whoami)
    lock_owner=$(stat "$BUILD_LOCK_LOCAL" -c "%U")

    if [[ "$cur_user" == "$lock_owner" ]] ; then
      rm -f "$BUILD_LOCK_LOCAL" &> /dev/null
      return 0
    else
      return 1
    fi
  fi

  return 0
}

localSign() {
  local package="$1"

  show "Signing package ${CL_CYAN}${package_name}${CL_NORM}..."

  if [[ -n "$verbose" ]] ; then
    rpm --addsign "$package" | tee "$tmp_output" &> $verb_output
  else
    rpm --addsign "$package" &> "$tmp_output"
  fi

  if [[ $? -ne 0 ]] ; then
    show "Can't sign package" $YELLOW
  fi
}

releaseBump() {
  local spec="$1"

  if [[ -n "$bump_comment" ]] ; then
    rpmdev-bumpspec -c "$bump_comment" "$spec"
  else
    rpmdev-bumpspec "$spec"
  fi

  if [[ $? -ne 0 ]] ; then
    error "Can't bump release - bumpspec return error code" $YELLOW
  fi
}

prepareDeps() {
  local dep deps fdep result

  deps=$(echo "$*" | sed 's/ \(>\|>=\|=\) /\1/g')

  for dep in $deps ; do
    if [[ $dep =~ \:\: ]] ; then
      fdep=$(echo "$dep" | sed 's/(\|::/-/g' | sed 's/)//g')
      result="$result $fdep"
    elif [[ $dep =~ (>=|>|=)[0-9A-Za-z.-]* ]] ; then
      result="$result ${dep//${BASH_REMATCH[0]}/}"
    else
      result="$result $dep"
    fi
  done

  echo "${result:1:9999}"
}

uploadPackages() {
  local packages_dir="$1"
  local packages="$2"

  local package_name package_list target has_errors

  for package in $packages ; do
    package_name=$(basename "$package")
    package_list="$package_list $packages_dir/$package_name"
  done

  showSeparator "PACKAGE UPLOADING"

  if [[ -f $upload ]] ; then
    if [[ -r $upload ]] ; then
      has_errors=""

      while read line ; do
        target=$(echo "$line" | cut -f1 -d":")
        uploadPackagesToServer "$line" "$package_list"

        [[ $? -ne 0 ]] && has_errors=true
      done < "$upload"

      show ""

      if [[ -n "$has_errors" ]] ; then
        show "All rpm packages saved to a directory ${CL_CYAN}$packages_dir${CL_NORM}"
      else
        rm -f "$package_list"
        show "All rpm packages uploaded to all remote servers" $GREEN
      fi
    else
      error "Can't read file ${CL_BL_RED}${upload}" $RED
      show ""
      show "All rpm packages saved to a directory ${CL_CYAN}${packages_dir}${CL_NORM}"
    fi
  else
    target=$(echo "$upload" | cut -f1 -d":")

    uploadPackagesToServer "$upload" "$package_list"

    show ""

    if [[ $? -eq 0 ]] ; then
      rm -f "$package_list"
      show "All rpm packages uploaded to a remote server" $GREEN
    else
      show "All rpm packages saved to a directory ${CL_CYAN}$packages_dir${CL_NORM}"
    fi
  fi
}

uploadPackagesToServer() {
  local url="$1"

  local url_user_host url_user url_host url_path package package_list package_name has_errors

  if [[ $(echo "$url" | tr -dc ":" | wc -c) == "2" ]] ; then
    url_user_host=$(echo "$url" | cut -f1-2 -d":")
    url_user=$(echo "$url_user_host" | cut -f1 -d"@" | cut -f1 -d":")
    url_host=$(echo "$url_user_host" | cut -f2 -d"@")
    url_path=$(echo "$url" | cut -f2 -d":")
  else
    url_user_host=$(echo "$url" | cut -f1 -d":")
    url_user=$(echo "$url_user_host" | cut -f1 -d"@")
    url_host=$(echo "$url_user_host" | cut -f2 -d"@")
    url_path=$(echo "$url" | cut -f2 -d":")
  fi

  show "Connecting to remote server ${CL_CYAN}${url_host}${CL_NORM}..."

  if isRemoteServerReachable "$url_host" ; then
    if isSSHConnectionWorks "$url_user" "$url_host" ; then
      has_errors=""

      for package in $package_list ; do
        package_name=$(basename "$package")

        scpCommand "$package" "$url" &> $verb_output

        if [[ $? -eq 0 ]] ; then
          show "Package ${CL_CYAN}$package_name${CL_NORM} uploaded to remote host"
        else
          error "Can't upload package ${CL_BL_RED}${package_name}${CL_RED} to a directory ${CL_BL_RED}${url_path}${CL_RED} on ${CL_BL_RED}${url_host}${CL_NORM}"
          has_errors=true
        fi
      done

      [[ -n "$has_errors" ]] && return 1
    else
      error "Remote server ${CL_BL_RED}${url_host}${CL_RED} not accessible!" $RED
      return 1
    fi
  else
    error "Remote server ${CL_BL_RED}${url_host}${CL_RED} not accessible!" $RED
    return 1
  fi

  return 0
}

packSources() {
  show "Packing source files to archive..."

  local spec="$1"

  if [[ -n "$source_list" ]] ; then
    if [[ ! -r $source_list ]] ; then
      error "Can't pack sources - file ${CL_BL_RED}${source_list}${CL_RED} not readable" $RED
      doExit $ERROR_SOURCE
    fi

    if [[ ! -s $source_list ]] ; then
      error "Can't pack sources - file ${CL_BL_RED}${source_list}${CL_RED} is empty" $RED
      doExit $ERROR_SOURCE
    fi

    pack=$(cat "$source_list")
    pack=$(renderMacros "$spec" "$pack")
  fi

  local src_target sources arch_name arch_ext

  for src_target in $pack ; do
    if [[ ! -a $src_target ]] ; then
      error "Can't pack sources - ${CL_BL_RED}${src_target}${CL_RED} not exist or not accesable" $RED
      doExit $ERROR_SOURCE
    fi
  done

  sources=($(getSpecValue "$MACRO_SOURCE" "$spec"))
  arch_name=$(getArchName "${sources[0]}")
  arch_ext=$(getArchExt "${sources[0]}")

  mkdir -p "$tmp_dir/$arch_name"

  if [[ -z "$relative_pack" ]] ; then
    cp -r $pack "$tmp_dir/$arch_name" &> /dev/null
  else
    cp -r --parents $pack "$tmp_dir/$arch_name" &> /dev/null
  fi

  if [[ $? -ne 0 ]] ; then
    error "Can't copy source files to a temporary directory" $RED
    doExit 1
  fi

  cleanPackDir "$tmp_dir/$arch_name"

  pushd "$tmp_dir" &> /dev/null

    packDir "$tmp_dir/$arch_name" "$arch_ext"

  popd &> /dev/null

  rm -rf "${tmp_dir:?}/$arch_name"

  show "All files packed to ${CL_BL_GREEN}${arch_name}.${arch_ext}" $GREEN
}

packSourcesFromGit() {
  local spec sources source_name source_ext dir_name git_log abs_dir_path

  spec=$(getAbsPath "$1")
  sources=($(getSpecValue "$MACRO_SOURCE" "$spec"))

  if findSource "${sources[0]}" &>/dev/null ; then
    if [[ -n "$download" ]] ; then
      show "File ${CL_CYAN}${sources[0]}${CL_NORM} already created."
    fi

    return
  fi

  source_name=$(getArchName "${sources[0]}")
  source_ext=$(getArchExt "${sources[0]}")

  show "Fetching sources from git repo ${CL_CYAN}$git${CL_NORM}..."

  dir_name=$(mktemp -u "$source_name-XXXX")

  git_log="$tmp_dir/git.log"

  pushd "$tmp_dir" &> /dev/null
    git=$(renderMacros "$spec" "$git")

    [[ -n "$verbose" ]] && git clone "$git" "$dir_name" | tee -a "$git_log" || git clone "$git" "$dir_name" &> "$git_log"

    if [[ $? -ne 0 ]] ; then
      error "Can't clone repo - error while cloning" $RED

      if [[ -z "$verbose" ]] ; then
        error ""
        error "Last ${REPO_LOG_QUOTE_SIZE} lines from log ($git_log):"
        tail -${REPO_LOG_QUOTE_SIZE} "$git_log" 1>&2
        error ""
      fi

      doExit $ERROR_SOURCE
    fi

    pushd "$tmp_dir/$dir_name" &> /dev/null

      if [[ -n "$branch" ]] ; then
        branch=$(renderMacros "$spec" "$branch")

        [[ -n "$verbose" ]] && git checkout "$branch" | tee -a "$git_log" || git checkout "$branch" &> "$git_log"

        if [[ $? -ne 0 ]] ; then
          error "Can't switch branch to ${CL_BL_RED}${branch}${CL_RED}:" $RED

          if [[ -z "$verbose" ]] ; then
            error ""
            error "Last ${REPO_LOG_QUOTE_SIZE} lines from log ($git_log):"
            tail -${REPO_LOG_QUOTE_SIZE} "$git_log" 1>&2
            error ""
          fi

          doExit $ERROR_SOURCE
        fi
      fi

      if [[ -n "$revision" ]] ; then
        [[ -n "$verbose" ]] && git checkout "$revision" | tee -a "$git_log" || git checkout "$revision" &> "$git_log"

        if [[ $? -ne 0 ]] ; then
          error "Can't checkout revision ${CL_BL_RED}${revision}${CL_RED}:" $RED

          if [[ -z "$verbose" ]] ; then
            error ""
            error "Last ${REPO_LOG_QUOTE_SIZE} lines from log ($git_log):"
            tail -${REPO_LOG_QUOTE_SIZE} "$git_log" 1>&2
            error ""
          fi

          doExit $ERROR_SOURCE
        fi
      elif [[ -n "$tag" ]] ; then
        tag=$(renderMacros "$spec" "$tag")

        [[ -n "$verbose" ]] && git checkout "$tag" | tee -a "$git_log" || git checkout "$tag" &> "$git_log"

        if [[ $? -ne 0 ]] ; then
          error "Can't checkout tag ${CL_BL_RED}${tag}${CL_RED}:" $RED

          if [[ -z "$verbose" ]] ; then
            error ""
            error "Last ${REPO_LOG_QUOTE_SIZE} lines from log ($git_log):"
            tail -${REPO_LOG_QUOTE_SIZE} "$git_log" 1>&2
            error ""
          fi

          doExit $ERROR_SOURCE
        fi
      fi

      # Fetch submodules if exist
      if [[ -f .gitmodules ]] ; then
        git submodule update --init --recursive
      fi

      rm -rf .git .gitignore .gitmodules "$git_log" &> /dev/null
    popd &> /dev/null

    if [[ -n "$path" ]] ; then
      if [[ ! -d "$dir_name/$path" ]] ; then
        error "Can't find path ${CL_BL_RED}${path}${CL_NORM} in git repository" $RED
        doExit $ERROR_SOURCE
      else
        mv "$dir_name/$path" "$source_name"
        rm -rf "$dir_name"
      fi
    else
      mv "$dir_name" "$source_name"
    fi

    abs_dir_path=$(getAbsPath "$tmp_dir/$source_name")

    packDir "$abs_dir_path" "$source_ext"

    rm -rf "$source_name"

    if [[ -n "$dlcache" ]] ; then
      cp "${source_name}.${source_ext}" "$dlcache/"
    fi

  popd &> /dev/null

  show "Source files from ${CL_BOLD}git${CL_NORM} repo packed as ${CL_CYAN}${source_name}.${source_ext}${CL_NORM}\n"
}

packSourcesFromHg() {
  local spec sources source_name source_ext dir_name hg_log abs_dir_path

  spec=$(getAbsPath "$1")
  sources=($(getSpecValue "$MACRO_SOURCE" "$spec"))

  if findSource "${sources[0]}" &>/dev/null ; then
    if [[ -n "$download" ]] ; then
      show "File ${CL_CYAN}${sources[0]}${CL_NORM} already created."
    fi

    return
  fi

  source_name=$(getArchName "${sources[0]}")
  source_ext=$(getArchExt "${sources[0]}")

  show "Fetching sources from hg repo ${CL_CYAN}$hg${CL_NORM}..."

  dir_name=$(mktemp -u "$source_name-XXXX")

  hg_log="$tmp_dir/hg.log"

  pushd "$tmp_dir" &> /dev/null
    hg=$(renderMacros "$spec" "$hg")

    [[ -n "$verbose" ]] && hg clone "$hg" "$dir_name" | tee -a "$hg_log" || hg clone "$hg" "$dir_name" &> "$hg_log"

    if [[ $? -ne 0 ]] ; then
      error "Can't clone repo - error while cloning" $RED

      if [[ -z "$verbose" ]] ; then
        error ""
        error "Last ${REPO_LOG_QUOTE_SIZE} lines from log ($hg_log):"
        tail -${REPO_LOG_QUOTE_SIZE} "$hg_log" 1>&2
        error ""
      fi

      doExit $ERROR_SOURCE
    fi

    pushd "$tmp_dir/$dir_name" &> /dev/null

      if [[ -n "$branch" ]] ; then
        branch=$(renderMacros "$spec" "$branch")

        [[ -n "$verbose" ]] && hg checkout "$branch" | tee -a "$hg_log" || hg checkout "$branch" &> "$hg_log"

        if [[ $? -ne 0 ]] ; then
          error "Can't switch branch to ${CL_BL_RED}${branch}${CL_RED}:" $RED

          if [[ -z "$verbose" ]] ; then
            error ""
            error "Last ${REPO_LOG_QUOTE_SIZE} lines from log ($hg_log):"
            tail -${REPO_LOG_QUOTE_SIZE} "$hg_log" 1>&2
            error ""
          fi

          doExit $ERROR_SOURCE
        fi
      fi

      if [[ -n "$revision" ]] ; then
        [[ -n "$verbose" ]] && hg checkout "$revision" | tee -a "$hg_log" || hg checkout "$revision" &> "$hg_log"

        if [[ $? -ne 0 ]] ; then
          error "Can't checkout revision ${CL_BL_RED}${revision}${CL_RED}:" $RED

          if [[ -z "$verbose" ]] ; then
            error ""
            error "Last ${REPO_LOG_QUOTE_SIZE} lines from log ($hg_log):"
            tail -${REPO_LOG_QUOTE_SIZE} "$hg_log" 1>&2
            error ""
          fi

          doExit $ERROR_SOURCE
        fi
      elif [[ -n "$tag" ]] ; then
        tag=$(renderMacros "$spec" "$tag")

        [[ -n "$verbose" ]] && hg checkout "$tag" | tee -a "$hg_log" || hg checkout "$tag" &> "$hg_log"

        if [[ $? -ne 0 ]] ; then
          error "Can't checkout tag ${CL_BL_RED}${tag}${CL_RED}:" $RED

          if [[ -z "$verbose" ]] ; then
            error ""
            error "Last ${REPO_LOG_QUOTE_SIZE} lines from log ($hg_log):"
            tail -${REPO_LOG_QUOTE_SIZE} "$hg_log" 1>&2
            error ""
          fi

          doExit $ERROR_SOURCE
        fi
      fi

      rm -rf .hg .hgignore "$hg_log" &> /dev/null
    popd &> /dev/null

    if [[ -n "$path" ]] ; then
      if [[ ! -d "$dir_name/$path" ]] ; then
        error "Can't find path ${CL_BL_RED}${path}${CL_NORM} in mercurial repository" $RED
        doExit $ERROR_SOURCE
      else
        mv "$dir_name/$path" "$source_name"
        rm -rf "$dir_name"
      fi
    else
      mv "$dir_name" "$source_name"
    fi

    abs_dir_path=$(getAbsPath "$tmp_dir/$source_name")

    packDir "$abs_dir_path" "$source_ext"

    rm -rf "$source_name"

    if [[ -n "$dlcache" ]] ; then
      cp "${source_name}.${source_ext}" "$dlcache/"
    fi

  popd &> /dev/null

  show "Source files from ${CL_BOLD}hg${CL_NORM} repo packed as ${CL_CYAN}${source_name}.${source_ext}${CL_NORM}\n"
}

packSourcesFromBzr() {
  local spec sources source_name source_ext dir_name bzr_log bzr_opts abs_dir_path

  spec=$(getAbsPath "$1")
  sources=($(getSpecValue "$MACRO_SOURCE" "$spec"))

  if findSource "${sources[0]}" &>/dev/null ; then
    if [[ -n "$download" ]] ; then
      show "File ${CL_CYAN}${sources[0]}${CL_NORM} already created."
    fi

    return
  fi

  source_name=$(getArchName "${sources[0]}")
  source_ext=$(getArchExt "${sources[0]}")

  show "Fetching sources from bzr repo ${CL_CYAN}${bzr}${CL_NORM}..."

  bzr=$(renderMacros "$spec" "$bzr")

  dir_name=$(mktemp -u "$source_name-XXXX")
  bzr_log="$tmp_dir/bzr.log"

  pushd "$tmp_dir" &> /dev/null

    [[ -n "$tag" ]] && bzr_opts="-r tag:$tag"

    [[ -n "$verbose" ]] && bzr $bzr_opts branch "$bzr" "$dir_name" | tee -a "$bzr_log" || bzr $bzr_opts branch "$bzr" "$dir_name" &> "$bzr_log"

    if [[ $? -ne 0 ]] ; then
      error "Can't make a copy of the branch" $RED

      if [[ -z "$verbose" ]] ; then
        error ""
        error "Last ${REPO_LOG_QUOTE_SIZE} lines from log ($bzr_log):"
        tail -${REPO_LOG_QUOTE_SIZE} "$bzr_log" 1>&2
        error ""
      fi

      doExit $ERROR_SOURCE
    fi

    pushd "$tmp_dir/$dir_name" &> /dev/null

      if [[ -n "$revision" ]] ; then
        [[ -n "$verbose" ]] && bzr revert -r${revision} | tee -a "$bzr_log" || bzr revert -r${revision} &> "$bzr_log"

        if [[ $? -ne 0 ]] ; then
          error "Can't revert to revision ${CL_BL_RED}${revision}" $RED

          if [[ -z "$verbose" ]] ; then
            error ""
            error "Last ${REPO_LOG_QUOTE_SIZE} lines from log ($bzr_log):"
            tail -${REPO_LOG_QUOTE_SIZE} "$bzr_log" 1>&2
            error ""
          fi

          doExit $ERROR_SOURCE
        fi
      fi

      rm -rf .bzr .bzrignore "$bzr_log" &> /dev/null
    popd &> /dev/null

    if [[ -n "$path" ]] ; then
      if [[ ! -d "$dir_name/$path" ]] ; then
        error "Can't find path ${CL_BL_RED}${path}${CL_NORM} in bazaar repository" $RED
        doExit $ERROR_SOURCE
      else
        mv "$dir_name/$path" "$source_name"
        rm -rf "$dir_name"
      fi
    else
      mv "$dir_name" "$source_name"
    fi

    abs_dir_path=$(getAbsPath "$tmp_dir/$source_name")

    packDir "$abs_dir_path" "$source_ext"

    rm -rf "$source_name"

    if [[ -n "$dlcache" ]] ; then
      cp "${source_name}.${source_ext}" "$dlcache/"
    fi

  popd &> /dev/null

  show "Source files from ${CL_BOLD}bzr${CL_NORM} repo packed as ${CL_CYAN}${source_name}.${source_ext}${CL_NORM}\n"
}

packSourcesFromSvn() {
  local spec sources source_name source_ext svn_opts svn_log abs_dir_path

  spec=$(getAbsPath "$1")
  sources=($(getSpecValue "$MACRO_SOURCE" "$spec"))

  if findSource "${sources[0]}" &>/dev/null ; then
    if [[ -n "$download" ]] ; then
      show "File ${CL_CYAN}${sources[0]}${CL_NORM} already created."
    fi

    return
  fi

  source_name=$(getArchName "${sources[0]}")
  source_ext=$(getArchExt "${sources[0]}")

  show "Fetching sources from svn repo ${CL_CYAN}$svn${CL_NORM}..."

  svn=$(renderMacros "$spec" "$svn")

  svn_log="$tmp_dir/svn.log"
  svn_opts="--non-interactive --no-auth-cache"

  [[ -n "$svn_user" ]] && svn_opts="$svn_opts --username $svn_user"
  [[ -n "$svn_pass" ]] && svn_opts="$svn_opts --password $svn_pass"
  [[ -n "$revision" ]] && svn_opts="$svn_opts --revision $revision"

  local svn_url

  if [[ "$svn" =~ (branches|tags|trunk) ]] ; then
    svn_url="$svn"
  else
    if [[ -n "$branch" ]] ; then
      branch=$(renderMacros "$spec" "$branch")
      svn_url="$svn/branches/$branch"
    elif [[ -n "$tag" ]] ; then
      tag=$(renderMacros "$spec" "$tag")
      svn_url="$svn/tags/$tag"
    else
      svn_url="$svn/trunk"
    fi
  fi

  pushd "$tmp_dir" &> /dev/null
    if [[ -n "$path" ]] ; then
      if [[ -n "$verbose" ]] ; then
        svn checkout "$svn_url" "${source_name}_tmp" $svn_opts | tee -a "$svn_log"
      else
        svn checkout "$svn_url" "${source_name}_tmp" "$svn_opts" &> "$svn_log"
      fi
    else
      if [[ -n "$verbose" ]] ; then
        svn checkout "$svn_url" "${source_name}" $svn_opts | tee -a "$svn_log"
      else
        svn checkout "$svn_url" "${source_name}" $svn_opts &> "$svn_log"
      fi
    fi

    if [[ $? -ne 0 ]] ; then
      error "Can't checkout source code from ${CL_BL_RED}${svn}" $RED

      if [[ -z "$verbose" ]] ; then
        error ""
        error "Last ${REPO_LOG_QUOTE_SIZE} lines from log ($svn_log):"
        tail -${REPO_LOG_QUOTE_SIZE} "$svn_log" 1>&2
        error ""
      fi

      doExit $ERROR_SOURCE
    else
      rm -f "$svn_log" &> /dev/null

      if [[ -n "$path" ]] ; then
        if [[ ! -d "${source_name}_tmp/$path" ]] ; then
          error "Can't find path ${CL_BL_RED}${path}${CL_NORM} in svn repository" $RED
          doExit $ERROR_SOURCE
        else
          mv "${source_name}_tmp/$path" "$source_name"
          rm -rf "${source_name}_tmp"
        fi
      fi

      find "$source_name" -type d -name ".svn" -exec rm -rf {} \; &> /dev/null

      abs_dir_path=$(getAbsPath "$tmp_dir/$source_name")

      packDir "$abs_dir_path" "$source_ext"

      rm -rf "$source_name"
    fi

    if [[ -n "$dlcache" ]] ; then
      cp "${source_name}.${source_ext}" "$dlcache/"
    fi

  popd &> /dev/null

  show "Source files from ${CL_BOLD}svn${CL_NORM} repo packed as ${CL_CYAN}${source_name}.${source_ext}${CL_NORM}\n"
}

packGolangSources() {
  local spec="$1"
  local args sources output status

  sources=($(getSpecValue "$MACRO_SOURCE" "$spec"))

  if findSource "${sources[0]}" &>/dev/null ; then
    if [[ -n "$download" ]] ; then
      show "File ${CL_CYAN}${sources[0]}${CL_NORM} already created."
    fi

    return
  fi

  if [[ -n "$download" ]] ; then
    output="${download}/${sources[0]}"
  else
    output="${sources[0]}"
  fi

  args="-o $output"

  [[ -n "$revision" ]] && args="$args -r $revision"
  [[ -n "$branch" ]]   && args="$args -b $branch"
  [[ -n "$tag" ]]      && args="$args -t $tag"
  [[ -n "$verbose" ]]  && args="$args -V"

  args="$args $gopack"

  gopack $args

  if [[ $? -ne 0 ]] ; then
    showSeparator
    doExit 1
  fi
}

processSpec() {
  local spec="$1"

  local source_list patch_list files source_file source_num file_name found_source

  source_list=$(getSpecValue "$MACRO_SOURCE" "$spec")
  patch_list=$(getSpecValue "$MACRO_PATCH" "$spec")

  files="$source_list $patch_list"

  source_num=0

  for source_file in $files ; do
    if [[ -n "${svn}${git}${hg}${bzr}" ]] ; then
      [[ $source_num -eq 0 ]] && ((source_num++)) && continue
    fi

    if [[ "$source_file" =~ (http|https|ftp) ]] ; then
      file_name=$(basename "$source_file")
      found_source=$(findSource "$file_name")

      if [[ -n "$found_source" ]] ; then
        show "File ${CL_CYAN}$file_name${CL_NORM} listed in spec and will be used for the build"
        cp "$found_source" "$tmp_dir"
      elif [[ -f "$tmp_dir/$file_name" ]] ; then
        show "File ${CL_CYAN}$file_name${CL_NORM} listed in spec and will be used for the build"
      elif [[ -n "$dlcache" ]] ; then
        if [[ -f "$dlcache/$file_name" ]] ; then
          show "File ${CL_CYAN}$file_name${CL_NORM} listed in spec and will be used for the build"
          cp "$dlcache/$file_name" "$tmp_dir"
        else
          show "Downloading source file ${CL_CYAN}${source_file}${CL_NORM}..."

          downloadSource "$source_file" "$dlcache"

          if [[ $? -ne 0 ]] ; then
            error "Error! Can't download file ${CL_BL_RED}${source_file}${CL_RED}." $RED
            doExit $ERROR_SOURCE
          fi

          cp "$dlcache/$file_name" "$tmp_dir"
        fi
      else
        show "Downloading source file ${CL_CYAN}${source_file}${CL_NORM}..."

        downloadSource "$source_file" "$tmp_dir"

        if [[ $? -ne 0 ]] ; then
          error "Error! Can't download file ${CL_BL_RED}${source_file}${CL_RED}." $RED
          doExit $ERROR_SOURCE
        fi
      fi
    else
      if [[ -f "$tmp_dir/$source_file" ]] ; then
        show "File ${CL_CYAN}${source_file}${CL_NORM} listed in spec and will be used for the build"
        source_num=$(( source_num + 1 )) && continue
      fi

      local source_ext source_name found_dir found_source

      source_ext=$(getArchExt "$source_file")
      source_name=$(getArchName "$source_file")
      found_dir=$(findSource "$source_name" true)
      found_source=$(findSource "$source_file")

      if [[ -n "$source_ext" && -n "$found_dir" ]] ; then
        show "File ${CL_CYAN}${source_file}${CL_NORM} listed in spec and will be created from sources directory"

        packDir "$found_dir/$source_name" "$source_ext"
        mv "$found_dir/$source_file" "$tmp_dir"

        source_num=$(( source_num + 1 )) && continue
      elif [[ -n "$found_source" ]] ; then
        show "File ${CL_CYAN}${source_file}${CL_NORM} listed in spec and will be used for build"

        cp "$found_source" "$tmp_dir"

        source_num=$(( source_num + 1 )) && continue
      else
        error "Can't use file ${CL_BL_RED}${source_file}${CL_RED} for build - file not found in sources directory" $RED
        doExit $ERROR_SOURCE
      fi
    fi

    source_num=$(( source_num + 1 ))
  done
}

findSource() {
  local name="$1"
  local get_dir="$2"

  local dir abs_dir

  if [[ -n "$source_dir" ]] ; then
    if [[ -r "$source_dir/$name" ]] ; then
      if [[ -n "$get_dir" ]] ; then
        echo "$source_dir" && return 0
      else
        echo "$source_dir/$name" && return 0
      fi
    fi
  else
    for dir in $SOURCE_PATHS ; do
      abs_dir=$(getAbsPath "$dir")

      if [[ -r "$abs_dir/$name" ]] ; then
        if [[ -n "$get_dir" ]] ; then
          echo "$abs_dir" && return 0
        else
          echo "$abs_dir/$name" && return 0
        fi
      fi
    done
  fi

  echo "" && return 1
}

copySourcesToBuildDir() {
  local spec="$1"

  local rpmbuild_dir src_dir specs_dir source_file source_files source_file_name has_errors

  rpmbuild_dir=$(getRPMBuildDir)
  src_dir="$rpmbuild_dir/SOURCES"
  specs_dir="$rpmbuild_dir/SPECS"

  if [[ -d "$src_dir" ]] ; then
    source_files=$(find "$tmp_dir" -maxdepth 1 -type f)

    for source_file in $source_files ; do
      cp "$source_file" "$src_dir" &> /dev/null

      if [[ $? -ne 0 ]] ; then
        source_file_name=$(basename "$source_file")
        error "Can't copy source file ${CL_BL_RED}${source_file_name}${CL_RED} to directory ${CL_BL_RED}${src_dir}${CL_RED} - error while copy process" $RED
        doExit $ERROR_SOURCE
      fi
    done
  else
    error "Error! Can't copy source files - directory ${CL_BL_RED}${src_dir}${CL_RED} doesn't exist" $RED
    doExit $ERROR_SOURCE
  fi

  if [[ -d $specs_dir ]] ; then
    cp "$spec" "$specs_dir"

    if [[ $? -ne 0 ]] ; then
      error "Can't copy spec file - error while copy process"
      doExit $ERROR_SOURCE
    fi

    [[ -n "$bump" ]] && releaseBump "$specs_dir/$spec"
  else
    error "Error! Can't copy spec file - directory ${CL_BL_RED}${specs_dir}${CL_RED} doesn't exist." $RED
    doExit $ERROR_SOURCE
  fi
}

uploadSourcesToRemoteHost() {
  local spec="$1"

  local source_file source_files rmpbuild_dir

  rmpbuild_dir=$(getRPMBuildDir)
  source_files=$(find "$tmp_dir" -maxdepth 1 -type f)

  for source_file in $source_files ; do
    source_file_name=$(basename "$source_file")

    showt "${CL_CYAN}${source_file_name}${CL_NORM}" 4

    scpCommand "$source_file" "$user@$host:$rmpbuild_dir/SOURCES/" &> $verb_output

    show "DONE" $GREEN
  done

  showt "${CL_CYAN}${spec}${CL_NORM}" 4

  if [[ -n "$bump" ]] ; then
    cp "$spec" "$tmp"

    releaseBump "$tmp/$spec"
    scpCommand "$tmp/$spec" "$user@$host:$rmpbuild_dir/SPECS/" &> $verb_output

    rm -f "$tmp/$spec"
  else
    scpCommand "$spec" "$user@$host:$rmpbuild_dir/SPECS/" &> $verb_output
  fi

  show "DONE" $GREEN
}

downloadFromRemoteHost() {
  local file="$1"
  local dir="$2"

  [[ -z "$dir" ]] && dir="$CWD"

  local file_name mod_ts

  file_name=$(basename "$file")

  if [[ -f $dir/$file_name ]] ; then
    mod_ts=$(stat -c "%Y" "$dir/$file_name")

    if [[ $mod_ts -ge $build_start && $mod_ts -le $build_end ]] ; then
      return 1
    else
      scpCommand "$user@$host:$file" "$dir" &> $verb_output
    fi
  else
    scpCommand "$user@$host:$file" "$dir" &> $verb_output
  fi
}

cleanPackDir() {
  local dir="$1"

  find "$dir" -type d -name ".git" -exec rm -rf {} \; 2> /dev/null
  find "$dir" -type d -name ".hg" -exec rm -rf {} \; 2> /dev/null
  find "$dir" -type d -name ".svn" -exec rm -rf {} \; 2> /dev/null
  find "$dir" -type d -name ".bzr" -exec rm -rf {} \; 2> /dev/null

  find "$dir" -type f -name ".gitignore" -exec rm -f {} \; 2> /dev/null
  find "$dir" -type f -name ".hgignore" -exec rm -f {} \; 2> /dev/null
  find "$dir" -type f -name ".bzrignore" -exec rm -f {} \; 2> /dev/null
}

packDir() {
  local dir="$1"
  local ext="$2"

  local dir_name parent_dir arch_name

  dir_name=$(basename "$dir")
  parent_dir=$(dirname "$dir")

  if [[ -n "$3" ]] ; then
    arch_name="$3"
  else
    arch_name="$dir_name"
  fi

  pushd "$parent_dir" &> /dev/null

    if [[ "$ext" == "tar.gz" || "$ext" == "tgz" ]] ; then
      tar czfv "$arch_name.$ext" "$dir_name" &> $verb_output
    elif [[ "$ext" == "tar.bz2" || "$ext" == "tbz2" ]]; then
      tar cjfv "$arch_name.$ext" "$dir_name" &> $verb_output
    elif [[ "$ext" == "tar.bz" || "$ext" == "tbz" ]]; then
      tar cjfv "$arch_name.$ext" "$dir_name" &> $verb_output
    elif [[ "$ext" == "tar.xz" || "$ext" == "txz" ]] ; then
      tar cf - "$dir_name" | xz -9 -c - > "$arch_name.$ext"
    else
      error "Error! Unknown archive type." $RED
      doExit $ERROR_SOURCE
    fi

  popd &> /dev/null
}

downloadSource() {
  local url="$1"
  local dir="$2"

  local file_name start end time_diff

  file_name=$(basename "$url")

  if ! isAccessibleUrl "$url" ; then
    error "Can't download file ${CL_BL_RED}${file_name}${CL_RED} - server return error code" $RED
    doExit $ERROR_SOURCE
  else
    start=$(now)

    curl -A "$USER_AGENT" -L --max-redirs 10 --progress-bar "$url" -o "$dir/$file_name"

    end=$(now)
    time_diff=$(( end - start ))

    if [[ -z "$tmux_worker" && -z "$dlcache" && $time_diff -gt $LONG_DOWNLOADING ]] ; then
      show ""
      show "HINT: Downloading took more than $LONG_DOWNLOADING seconds. We strongly recommend use download" $YELLOW
      show "cache feature in this case. Use -dc <path> or --dlcache <path>." $YELLOW
      show ""
    fi
  fi
}

getSpecValue() {
  local value="$1"
  local spec="$2"

  local spec_header result

  spec_header=$(grep -v "^#" "$spec" | grep -n "%prep" | head -1 | cut -f1 -d":")
  result=$(grep -v "^#" "$spec" | head "-$spec_header" | egrep "$value*.*:" | sed 's/[\t]/ /g' | tr -s " " | cut -f2-99 -d" " | sed 's/,/ /g')

  result=$(renderMacros "$spec" "$result")
  result=$(echo "$result" | sed 's/ = /=/g' | sed 's/ >= />=/g' | sed 's/ > />/g' | sed 's/ *$//')

  [[ "$value" == "$MACRO_SOURCE" || "$value" == "$MACRO_PATCH" ]] && echo "${result// /%20}" || echo "$result"
}

renderMacros() {
  local spec="$1"
  local value="$2"

  local result="$value"

  if [[ "$result" =~ \% ]] ; then
    while : ; do
      local macro_name macro_value

      [[ "$result" =~ \%\{([A-Za-z0-9_?]{3,})\} ]] && macro_name="${BASH_REMATCH[1]}" || break

      macro_value=$(getMacroValue "$macro_name" "$spec")

      result=${result/"%{$macro_name}"/"$macro_value"} #"
    done
  fi

  echo "$result"
}

getMacroValue() {
  local macro="$1"
  local spec="$2"

  local result sys_macro inner_macro

  if [[ "$MACRO" =~ $macro:([A-Za-z]*) ]] ; then
    inner_macro="${BASH_REMATCH[1]}"

    result=$(grep -v "^#" "$spec" | egrep "$inner_macro*.:" | sed 's/[\t]/ /g' | tr -s " " | cut -f2-99 -d" " | sed 's/,/ /g' | sed 's/ $//g' | head -1)
  fi

  if [[ -z "$result" ]] ; then
    sys_macro=$(rpm --eval "%{$macro}")

    [[ ! $sys_macro =~ \% ]] && result="$sys_macro"
  fi

  if [[ -z "$result" ]] ; then
    result=$(grep -v "^#" "$spec" | egrep "(^%define|^%global)" | sed 's/[\t]/ /g' | tr -s " " | egrep "(^%define|^%global) $macro " | cut -f3-99 -d" ")
  fi

  echo "$result"
}

isAccessibleUrl() {
  local status code nosniff size

  if [[ "$1" =~ http:|https: ]] ; then
    status=$(curl -A "$USER_AGENT" -LIs --max-redirs 10 -X GET "$1")
    code=$(echo -e "$status" | grep "HTTP" | cut -f2 -d" " | tail -1)
    nosniff=$(echo -e "$status" | grep "X-Content-Type-Options: nosniff")

    # Nosniff mode works on Google Code, if we simple try check status server return
    # code 404, but we can download this file
    [[ -n $nosniff || "$code" == "200" ]] && return 0 || return 1
  elif [[ "$1" =~ ftp: ]] ; then
    status=$(curl -A "$USER_AGENT" "$1" -Is)
    size=$(echo "$status" | grep "Content-Length" | cut -f2 -d" ")

    [[ -n "$size" ]] && return 0 || return 1
  else
    return 1
  fi
}

sshCommand() {
  local host="$1"
  local comm="$2"
  local no_pass="$3"

  local ssh_opts
  ssh_opts=$(getSSHOpts)

  if [[ -n "$pass" && -z "$no_pass" ]] ; then
    sshpass -p "$pass" ssh $SSH_BASE_OPTS -t -t -q $ssh_opts "$host" "$comm"
  else
    ssh $SSH_BASE_OPTS -t -t -q $ssh_opts "$host" "$comm"
  fi

  return $?
}

scpCommand() {
  local from="$1"
  local to="$2"

  local ssh_opts
  ssh_opts=$(getSSHOpts)

  if [[ -n "$pass" ]] ; then
    sshpass -p "$pass" scp -q $SSH_BASE_OPTS $ssh_opts "$from" "$to"
  else
    scp -q $SSH_BASE_OPTS $ssh_opts "$from" "$to"
  fi

  return $?
}

getBuildArgs() {
  local args=""

  if [[ -n "$no_source" ]] ; then
    args="-bb"
  elif [[ -n "$no_binary" ]] ; then
    args="-bs"
  else
    args="-ba"
  fi

  [[ -n "$no_build" ]] && args="$args --nobuild"
  [[ -n "$no_deps" ]] && args="$args --nodeps"
  [[ -z "$no_clean" ]] && args="$args --rmspec --rmsource --clean"
  [[ -n "$arch" ]] && args="$args --target=$arch"
  [[ -n "$with" ]] && args=$(getBuildArgsWith "$args")
  [[ -n "$without" ]] && args=$(getBuildArgsWithout "$args")
  [[ -n "$verbose" ]] && args="$args --verbose"

  local macro_def

  if [[ -n "$define" ]] ; then
    for macro_def in $define ; do
      args="$args --define=\"${macro_def/=/ }\""
    done
  fi

  echo "$args"
}

getBuildPrfx() {
  local prfx="LC_ALL=C"

  [[ -n "$qa_rpaths" ]] && prfx="$prfx QA_RPATHS=$[ ${qa_rpaths//,/|} ]"

  echo "$prfx"
}

getBuildArgsWith() {
  local args="$1"
  local warg

  for warg in $with ; do
    args="$args --with $warg"
  done

  echo "$args"
}

getBuildArgsWithout() {
  local args="$1"
  local warg

  for warg in $without ; do
    args="$args --without $warg"
  done

  echo "$args"
}

isSSHConnectionWorks() {
  sshCommand "$1@$2" "echo 2>&1" &> /dev/null

  [[ $? -eq 0 ]] && return 0 || return 1
}

isRemoteServerReachable() {
  local host="$1"

  ping -c 1 -w 5 "$host" &> /dev/null

  [[ $? -eq 0 ]] && return 0 || return 1
}

getSSHOpts() {
  local opts

  if [[ -n "$key" ]] ; then
    opts="-i $key"
  else
    opts="-o PubkeyAuthentication=no"
  fi

  echo "$opts"
}

getYumOpts() {
  local verb="$1"

  local opts repo pkg

  [[ -z "$verb" ]] && opts="-q"

  if [[ -n "$enable_repo" ]] ; then
    for repo in $enable_repo ; do
      opts="$opts --enablerepo=$repo"
    done
  fi

  if [[ -n "$disable_repo" ]] ; then
    for repo in $disable_repo ; do
      opts="$opts --disablerepo=$repo"
    done
  fi

  if [[ -n "$exclude_package" ]] ; then
    for pkg in $exclude_package ; do
      opts="$opts --exclude=$pkg"
    done
  fi

  echo "$opts"
}

getRPMBuildDir() {
  if [[ "$user" == "root" ]] ; then
    echo "/root/rpmbuild"
  else
    echo "/home/$user/rpmbuild"
  fi
}

getArchName() {
  local file_name arch_type

  file_name=$(basename "$1")

  for arch_type in $SUPPORTED_ARCH_TYPES ; do
    file_name="${file_name/.${arch_type}/}"
  done

  echo "$file_name"
}

getArchExt() {
  local file_name arch_type

  file_name=$(basename "$1")

  for arch_type in $SUPPORTED_ARCH_TYPES ; do
    if [[ $file_name =~ $arch_type ]] ; then
      echo "$arch_type"
      return 0
    fi
  done

  echo ""
  return 1
}

isSpecFile() {
  [[ ! -r "$1" ]] && return 1
  [[ ! $(grep "%prep" "$1") ]] && return 1

  return 0
}

getURLVars() {
  local url="$1"

  local user pass user_pass host arch

  if [[ "$url" =~ \~ ]] ; then
    arch=$(echo "$url" | cut -f2 -d"~")
    url=$(echo "$url" | cut -f1 -d"~")
  fi

  if [[ "$url" =~ \@ ]] ; then
    user_pass=$(echo "$url" | cut -f1 -d"@")
    host=$(echo "$url" | cut -f2 -d"@")

    if [[ "$user_pass" =~ \: ]] ; then
      user=$(echo "$user_pass" | cut -f1 -d":")
      pass=$(echo "$user_pass" | cut -f2 -d":")
    else
      user="$user_pass"
    fi
  else
    host="$url"
  fi

  echo "${host:-} ${user:-} ${pass:-} ${arch:-}"
}

validatePackage() {
  local rpm_file rpm_name has_errors

  rpm_file="$1"
  rpm_name=$(basename "$rpm_file")

  showm "${CL_CYAN}${rpm_name}:${CL_NORM} "

  if rpm -qp --scripts "$rpm_file" 2>&1 | egrep -q '\%\{.*\}' ; then
    has_errors=true
    error "ERROR\n" $RED
    error "RPM package ${CL_BL_YELLOW}${rpm_name}${CL_YELLOW} contains unexpanded macroses in scriptlets:" $YELLOW
    error "${CL_GREY}"
    rpm -qp --scripts "$rpm_file" 2>&1 | egrep -A1 -B1 '\%\{.*\}' | sed '/^$/d' | sed 's/^/  /g' 1>&2
    error "${CL_NORM}"
  fi

  if rpm -qlp "$rpm_file" 2>&1 | egrep -q '\%\{.*\}' ; then
    has_errors=true
    error "ERROR\n" $RED
    error "RPM package ${CL_BL_YELLOW}${rpm_name}${CL_YELLOW} contains unexpanded macroses in files section:" $YELLOW
    error "${CL_GREY}"
    rpm -qlp "$rpm_file" 2>&1 | egrep -A1 -B1 '\%\{.*\}' | sed '/^$/d' | sed 's/^/  /g' 1>&2
    error "${CL_NORM}"
  fi

  if [[ -z "$has_errors" ]] ; then
    show "OK" $GREEN
    return 0
  fi

  return 1
}

###############################################################################

checkDeps() {
  local app

  for app in "$@" ; do
    type -P "$app" &> /dev/null
    [[ $? -eq 1 ]] && return 1
  done

  return 0
}

getAbsPath() {
  readlink -f "$1"
}

now() {
  date +'%s'
}

bell() {
  printf "\a"
}

getLogDate() {
  date +'%Y-%m-%d-%H%M'
}

getGraceTime() {
  local tim="$1"

  local sec min

  [[ -z "$tim" || "$tim" == "0" ]] && echo "< 1 sec" && return 0

  sec=$(( tim % 60 ))
  min=$(( ( tim - sec ) / 60 ))

  if [[ $min -eq 0 ]] ; then
    echo "$sec sec"
  else
    echo "$min min $sec sec"
  fi
}

startStatusObserver() {
  [[ -n "$verbose" ]] && return 0

  showt "\r${CL_GREEN}Executing:${CL_NORM} ${CL_CYAN}~${CL_NORM}"

  statusObserver &
  observer_pid=$!
}

stopStatusObserver() {
  [[ -n "$verbose" || -z "$observer_pid" ]] && return 0

  kill "$observer_pid" &> /dev/null
  wait "$observer_pid" &> /dev/null

  showm "\r${CL_GREEN}Executing:${CL_NORM} ${CL_CYAN}clean${CL_NORM}                                                               "
  show ""

  unset observer_pid
}

statusObserver() {
  local prev_status status

  while : ; do
    status=$(grep "Executing" "$tmp_output" | tail -1 | perl -ne '/Executing\(%(\w*)\)/ && print "$1\n"')

    if [[ "$status" == "doc" ]] ; then
      [[ $(grep "Checking for unpackaged" "$tmp_output") ]] && status="packaging"
    fi

    if [[ "$status" != "$prev_status" ]] ; then
      showt "\r${CL_GREEN}Executing:${CL_NORM} ${CL_CYAN}$status${CL_NORM}"
      prev_status="$status"
    fi

    sleep 0.1
  done
}

showSeparator() {
  local name="$1"
  local sep adds cols

  if [[ -n "$tmux_worker" ]] ; then
    cols=$(tmux display-message -p "#{window_width}")
  else
    cols=$(tput cols)
  fi

  for i in $(seq 1 $cols) ; do
    sep="${sep}-"
  done

  show ""

  if [[ -n "$name" ]] ; then
    adds=$(( ${#sep} - ${#name} - 4 ))
    show "${CL_GREY}--${CL_NORM} ${CL_BOLD}${name}${CL_NORM} ${CL_GREY}${sep:0:$adds}${CL_NORM}"
  else
    show "${CL_GREY}${sep}${CL_NORM}"
  fi

  show ""
}

show() {
  if [[ -n "$2" ]] ; then
    echo -e "\e[${2}m${1}\e[0m"
  else
    echo -e "$*"
  fi
}

showm() {
  if [[ -n "$2" ]] ; then
    echo -e -n "\e[${2}m${1}\e[0m"
  else
    echo -e -n "$*"
  fi
}

showt() {
  local message offset spaces adds

  message=$(echo "$1" | sed -r "s/\\\e\[([0-9;]{1,12}m)//g")
  offset="${2-0}"
  spaces="                                                                                      "

  adds=$((${#SEPARATOR} - ${#message} - $offset))

  echo -e -n "${1}${spaces:0:$adds}"
}

showo() {
  local optn optd optp optt optf breadcrumbs

  optn="$1"
  optd="$2"
  optp="$3"

  if [[ -n "$DARK" ]] ; then
    breadcrumbs="............................"
  else
    breadcrumbs="                            "
  fi

  if [[ -z "$optp" ]] ; then
    optt="$optn"
    optf=$(( 31 - ${#optt} ))
    echo -e "  ${CL_GREEN}${optn}${CL_NORM} ${CL_DARK}${breadcrumbs:0:$optf}${CL_NORM} $optd"
  else
    optt="$optn $optp"
    optf=$(( 31 - ${#optt} ))
    echo -e "  ${CL_GREEN}${optn}${CL_NORM} ${CL_GREY}${optp}${CL_NORM} ${CL_DARK}${breadcrumbs:0:$optf}${CL_NORM} $optd"
  fi
}

error() {
  show "$@" 1>&2
}

clean() {
  if [[ -e "$tmp_dir" ]] ; then
    rm -rf "$tmp_dir"
  fi

  if [[ -e "$tmp_output" ]] ; then
    rm -f "$tmp_output"
  fi
}

doExit() {
  clean

  stopStatusObserver

  if [[ -n "$tmux_worker" ]] ; then
    if [[ -z "$1" || "$1" == "0" ]] ; then
      sleep $TMUX_OK_SLEEP
    else
      [[ -z "$keep_log" || $1 -eq $ERROR_VALIDATE ]] && sleep $TMUX_ERROR_SLEEP
    fi
  fi

  exit "${1-0}"
}

termExit() {
  clean

  if hasLocalLock ; then
    removeLocalLock
  fi

  if [[ -z "$tmux_worker" ]] ; then
    if hasParalellLock ; then
      removeParalellLock
    fi
  else
    removeWorkerLock
  fi

  [[ -n "$observer_pid" ]] && stopStatusObserver

  exit $ERROR_UNKNOWN
}

###############################################################################

showArgWarn() {
  error "Error! Unknown argument $1." $RED
  doExit 1
}

usage() {
  show ""
  show "${CL_BOLD}Usage:${CL_NORM} rpmbuilder ${CL_YELLOW}{spec-file}${CL_NORM} ${CL_GREEN}{options}${CL_NORM}"
  show ""
  show "${CL_BOLD}Spec file:${CL_NORM}"
  show ""
  show "  You can define absolute or relative path to spec file. You also can define only spec name (without extension)."
  show "  In this case, rpmbuilder try use ${CL_YELLOW}{name}${CL_NORM}.spec file for build and try to find ${CL_YELLOW}{name}${CL_NORM}.source file and use as "
  show "  sources list."
  show ""
  show "Source packaging:" $BOLD
  show ""
  showo "--pack, -p" "Pack specified files to archive with default source name ${CL_DARK}(mergeable)${CL_NORM}" "files"
  showo "--relative-pack, -R" "Use relative path in source archive instead of absolute"
  showo "--source-dir, -sd" "Path to a directory which contains source files specified in spec file" "path"
  showo "--source-list, -sl" "Path to file which contains a list of source files specified in spec file" "file"
  showo "--dlcache, -dc" "Path to a directory for downloads caching" "dir"
  showo "--download, -dl" "Download all remote sources to a specified directory" "dir"
  show ""
  showo "--git" "Fetch sources from Git repository ${CL_DARK}(macro supported)${CL_NORM}" "url"
  showo "--svn" "Fetch sources from SVN repository ${CL_DARK}(macro supported)${CL_NORM}" "url"
  showo "--hg" "Fetch sources from Mercurial repository ${CL_DARK}(macro supported)${CL_NORM}" "url"
  showo "--bzr" "Fetch sources from Bazar repository ${CL_DARK}(macro supported)${CL_NORM}" "url"
  showo "--path, -rp" "Path to a directory with sources in repository" "path"
  showo "--branch, -rb" "Use specified repository branch ${CL_DARK}(macro supported)${CL_NORM}" "branch"
  showo "--revision, -rr" "Use specified revision" "rev"
  showo "--tag, -rt" "Use specified tag ${CL_DARK}(macro supported)${CL_NORM}" "tag"
  showo "--svn-user, -su" "Username for access to SVN repository" "username"
  showo "--svn-pass, -sp" "Password for access to SVN repository" "password"
  show ""
  showo "--github, -gh" "Fetch sources from github.com repository by url ${CL_DARK}(macro supported)${CL_NORM}" "url"
  showo "--github, -gh" "Fetch sources from github.com repository by user and project" "user:project"
  showo "--github, -gh" "Fetch sources from github.com repository by user and project" "user/project"
  showo "--bitbucket, -bb" "Fetch sources from bitbucket.org repository by url ${CL_DARK}(macro supported)${CL_NORM}" "url"
  showo "--bitbucket, -bb" "Fetch sources from bitbucket.org repository by user and project" "user:project"
  showo "--bitbucket, -bb" "Fetch sources from bitbucket.org repository by user and project" "user/project"
  showo "--launchpad, -lp" "Fetch sources from launchpad.net repository by url ${CL_DARK}(macro supported)${CL_NORM}" "url"
  showo "--launchpad, -lp" "Fetch sources from launchpad.net repository by project name" "project-name"
  show ""
  showo "--gopack, -G" "Fetch and pack golang sources using gopack" "url"
  show ""
  show "  Examples:" $BOLD
  show ""
  show "    rpmbuilder package.spec -sl sources/current -d ~/mypackages" $GREY
  show "    rpmbuilder package.spec --source-list files.list --dest ~/mypackages" $GREY
  show "    rpmbuilder package.spec --pack \"file1 file2 dir1 dir2 file3\"" $GREY
  show "    rpmbuilder package.spec -p \"file1 file2\" -p \"dir1 dir2 file3\" -p file4" $GREY
  show "    rpmbuilder package.spec --git git://github.com/user/project.git --tag 1.3-12" $GREY
  show "    rpmbuilder package.spec --git git://github.com/%{vendor}/%{name}.git --tag \"v%{version}-%{release}\"" $GREY
  show "    rpmbuilder package.spec --git git://github.com/user/project.git -rb develop" $GREY
  show "    rpmbuilder package.spec --git git://github.com/user/project.git -rr f8debbfdbebb97f5d0ee2218edf1425ac219cff5" $GREY
  show "    rpmbuilder package.spec -bb user:project" $GREY
  show "    rpmbuilder package.spec --github https://github.com/user/project/" $GREY
  show "    rpmbuilder package.spec --gopack github.com/user/project --version v1.2.3" $GREY
  show ""
  show "Dependencies install:" $BOLD
  show ""
  showo "--dep-install, -di" "Automatically install build dependencies before build process"
  showo "--enable-repo, -ER" "Enable repositories ${CL_DARK}(mergeable)${CL_NORM}" "repo-name"
  showo "--disable-repo, -DR" "Disable repositories ${CL_DARK}(mergeable)${CL_NORM}" "repo-name"
  showo "--exclude-package, -EX" "Exclude package by name or glob ${CL_DARK}(mergeable)${CL_NORM}" "package"
  show ""
  show "Remote build:" $BOLD
  show ""
  showo "--parallel, -P" "Parallel build on all build servers in same time"
  showo "--remote, -r" "Build rpm package on remote server"
  showo "--remote, -r" "Build rpm package on the remote server with specified host, username and password" "user:pass@host"
  showo "--remote, -r" "Build rpm package on the remote servers listed in specified file" "file"
  showo "--host, -hh" "Remote host IP or domain name" "host"
  showo "--user, -uu" "Remote host user" "username"
  showo "--pass, -pp" "Password for specified user" "password"
  showo "--key, -kk" "Path to the private key for specified user" "file"
  show ""
  show "  Examples:" $BOLD
  show ""
  show "    rpmbuilder package.spec --remote -ru builder -rp mypass -rh 127.0.0.1" $GREY
  show "    rpmbuilder package.spec -r builder:mypass@127.0.0.1 -i ~/.ssh/id_dsa" $GREY
  show "    rpmbuilder package.spec --remote ~/servers.list --key ~/.ssh/id_dsa" $GREY
  show ""
  show "Build options:" $BOLD
  show ""
  showo "--no-build, -NB" "Don't execute any build stages"
  showo "--no-clean, -NC" "Don't remove source files and spec file after build"
  showo "--no-deps, -ND" "Don't verify build dependencies"
  showo "--no-binary, -NR" "Don't build binary packages"
  showo "--no-source, -NS" "Don't build source package"
  showo "--arch, -a" "Override target arch for a build" "arch"
  showo "--qa-rpaths" "Ignoring rpaths check" "\"<value>,...\""
  show ""
  show "Arguments passing:" $BOLD
  show ""
  showo "--with, -w" "Pass conditional parameters into a rpmbuild ${CL_DARK}(mergeable)${CL_NORM}" "param"
  showo "--without, -W" "Pass conditional parameters into a rpmbuild ${CL_DARK}(mergeable)${CL_NORM}" "param"
  showo "--define, -D" "Define MACRO with value (exist macro will be not redefined) ${CL_DARK}(mergeable)${CL_NORM}" "\"macro=value\""
  show ""
  show "  Examples:" $BOLD
  show ""
  show "    rpmbuilder package.spec --with ssl --with ldap" $GREY
  show "    rpmbuilder package.spec -w ssl -W ldap" $GREY
  show "    rpmbuilder package.spec --with \"ssl ldap\"" $GREY
  show "    rpmbuilder package.spec --define \"install_dir=/some/dir\" --define \"service_user=someone\"" $GREY
  show ""
  show "  More info: http://rpm5.org/docs/api/conditionalbuilds.html" $DARK
  show ""
  show "Spec validation:" $BOLD
  show ""
  showo "--no-lint, -0" "Don't check spec file before package build"
  showo "--strict, -1" "Don't build package if linter found errors in spec file"
  showo "--pedantic, -2" "Don't build package if linter found errors or warnings in spec file"
  show ""
  show "Other:" $BOLD
  show ""
  showo "--sign, -s" "Sign package after build"
  showo "--dest, -d" "Save built packages to a specified directory" "dir"
  showo "--keep-log, -kl" "Save build log after an unsuccessful build"
  showo "--bump, -b" "Bump release in spec file after a successful build"
  showo "--bump-comment, -bc" "Comment which will be added while release bump" "comment"
  showo "--tmp" "Path to a temporary directory" "dir"
  showo "--verbose, -V" "Verbose output"
  showo "--no-color, -C" "Disable colors in output"
  showo "--help, -h" "Show this help message"
  showo "--version, -v" "Show information about version"
  show ""
}

about() {
  show ""
  show "${CL_BL_CYAN}$APP${CL_NORM} ${CL_CYAN}$VER${CL_NORM} - RPM package build helper"
  show ""
  show "Copyright (C) 2009-$(date +%Y) ESSENTIAL KAOS" $DARK
  show "Essential Kaos Open Source License <https://essentialkaos.com/ekol>" $DARK
  show ""
}

## PREFS PARSING ##############################################################

unset arg argn argp

PREFS_FILE="${PREFS_FILE//\~/$HOME}"

if [[ -n "$PREFS_FILE" && -r "$PREFS_FILE" ]] ; then
  while read arg ; do
    arg="${arg/: /:}" ; argn="${arg%:*}" ; argp="${arg#*:}"
    [[ "$SUPPORTED_ARGS " =~ $argn\  ]] && declare "$argn=$argp"
  done < <(awk 1 "$PREFS_FILE")

  unset arg argn argp
fi

## ARGUMENTS PARSING 3 #################################################################

[[ $# -eq 0 ]] && main && exit $?

unset arg argn argm argv argt argk

argv="$*" ; argt=""

while [[ -n "$1" ]] ; do
  if [[ "$1" =~ \  && -n "$argn" ]] ; then
    declare "$argn=$1"

    unset argn && shift && continue
  elif [[ $1 =~ ^-{1}[a-zA-Z0-9]{1,2}+.*$ ]] ; then
    argm=${1:1}

    if [[ \ $SHORT_ARGS\  =~ \ $argm:!?([a-zA-Z0-9_]*) ]] ; then
      arg="${BASH_REMATCH[1]}"
    else
      declare -F showArgWarn &>/dev/null && showArgWarn "-$argm"
      shift && continue
    fi

    if [[ -z "$argn" ]] ; then
      argn=$arg
    else
      [[ -z "$argk" ]] && ( declare -F showArgValWarn &>/dev/null && showArgValWarn "--$argn" ) || declare "$argn=true"
      argn=$arg
    fi

    if [[ ! $SUPPORTED_ARGS\  =~ !?$argn\  ]] ; then
      declare -F showArgWarn &>/dev/null && showArgWarn "-$argm"
      shift && continue
    fi

    if [[ ${BASH_REMATCH[0]:0:1} == "!" ]] ; then
      declare "$argn=true" ; unset argn ; argk=true
    else
      unset argk
    fi

    shift && continue
  elif [[ "$1" =~ ^-{2}[a-zA-Z]{1}[a-zA-Z0-9_-]+.*$ ]] ; then
    arg=${1:2}

    if [[ $arg == *=* ]] ; then
      IFS="=" read -ra arg <<< "$arg"

      argm="${arg[0]}" ; argm=${argm//-/_}

      if [[ ! $SUPPORTED_ARGS\  =~ $argm\  ]] ; then
        declare -F showArgWarn &>/dev/null && showArgWarn "--${arg[0]//_/-}"
        shift && continue
      fi

      [[ -n "${!argm}" && $MERGEABLE_ARGS\  =~ $argm\  ]] && declare "$argm=${!argm} ${arg[@]:1:99}" || declare "$argm=${arg[@]:1:99}"

      unset argm && shift && continue
    else
      arg=${arg//-/_}

      if [[ -z "$argn" ]] ; then
        argn=$arg
      else
        [[ -z "$argk" ]] && ( declare -F showArgValWarn &>/dev/null && showArgValWarn "--$argn" ) || declare "$argn=true"
        argn=$arg
      fi

      if [[ ! $SUPPORTED_ARGS\  =~ !?$argn\  ]] ; then
        declare -F showArgWarn &>/dev/null && showArgWarn "--${argn//_/-}"
        shift && continue
      fi

      if [[ ${BASH_REMATCH[0]:0:1} == "!" ]] ; then
        declare "$argn=true" ; unset argn ; argk=true
      else
        unset argk
      fi

      shift && continue
    fi
  else
    if [[ -n "$argn" ]] ; then
      [[ -n "${!argn}" && $MERGEABLE_ARGS\  =~ $argn\  ]] && declare "$argn=${!argn} $1" || declare "$argn=$1"

      unset argn && shift && continue
    fi
  fi

  argt="$argt $1" ; shift

done

[[ -n "$argn" ]] && declare "$argn=true"

unset arg argn argm argk

[[ -n "$KEEP_ARGS" ]] && main $argv || main ${argt:1:9999}

########################################################################################
